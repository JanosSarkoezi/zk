# Funktionales Strategy Pattern in Java

## Frage

Wie sehe das Strategie Design Pattern in Java aus, wenn man funktional
programmieren moechte?

## Antwort

Wenn du das **Strategy Design Pattern** in Java funktional implementieren
möchtest, kannst du **Lambda-Ausdrücke** oder **Methodenreferenzen** verwenden,
um die verschiedenen Algorithmen (Strategien) darzustellen. Dies vereinfacht
die Implementierung erheblich, da keine separaten Klassen für jede Strategie
mehr erforderlich sind. Die Schnittstelle für die Strategien ist dann ein
**funktionales Interface**.

### 1. Funktionales Interface (Strategy Interface)

Zuerst definierst du ein funktionales Interface. Dies ist eine Schnittstelle mit genau einer abstrakten Methode. Die `@FunctionalInterface`-Annotation ist optional, aber es ist eine gute Praxis, sie zu verwenden, um sicherzustellen, dass die Schnittstelle die Regeln eines funktionalen Interfaces erfüllt.

```java
@FunctionalInterface
public interface IStrategy {
    void execute();
}
```

In diesem Beispiel hat `execute()` keine Parameter und keinen Rückgabewert. Du kannst die Methode aber so definieren, wie es für deinen Anwendungsfall sinnvoll ist.

### 2. Kontext (Context)

Der Kontext ist die Klasse, die die Strategie verwendet. Anstatt eine konkrete Strategie zu instanziieren, speichert der Kontext eine Instanz des funktionalen Interfaces. Der Konstruktor oder eine Setter-Methode kann verwendet werden, um die Strategie zu übergeben.

```java
public class Context {
    private IStrategy strategy;

    public Context(IStrategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy() {
        strategy.execute();
    }
}
```

### 3. Implementierung und Nutzung

Im Hauptprogramm oder an der Stelle, wo du die Strategie anwenden möchtest, erstellst du einfach Lambda-Ausdrücke oder Methodenreferenzen, die die verschiedenen Strategien repräsentieren. Du übergibst diese dann dem `Context`.

```java
public class Main {
    public static void main(String[] args) {
        // Strategie 1 mit einem Lambda-Ausdruck
        Context context1 = new Context(() -> System.out.println("Strategie 1 wird ausgeführt."));
        context1.executeStrategy();

        // Strategie 2 mit einem weiteren Lambda-Ausdruck
        Context context2 = new Context(() -> System.out.println("Strategie 2 wird ausgeführt."));
        context2.executeStrategy();

        // Strategie 3 mit einer Methodenreferenz
        // Angenommen, es gibt eine statische Methode namens 'runStrategy3'
        // Context context3 = new Context(Main::runStrategy3);
        // context3.executeStrategy();
    }

    // Beispiel für eine Methode, die als Strategie verwendet werden könnte
    // public static void runStrategy3() {
    //     System.out.println("Strategie 3 wird ausgeführt.");
    // }
}
```

Die funktionale Implementierung des Strategy Pattern ist **kürzer und
flexibler** als die traditionelle, objektorientierte Version. Anstatt eine
Hierarchie von Klassen zu erstellen, die alle eine gemeinsame Schnittstelle
implementieren, verwendest du einfach Lambda-Ausdrücke direkt an der Stelle, wo
sie gebraucht werden. Dies reduziert Boilerplate-Code und macht das Design
eleganter. Es ist ein gutes Beispiel dafür, wie funktionale Programmierung die
klassischen GoF-Design-Patterns modernisieren kann.

## Frage

Kann das auch fuer das State Pattern gelten?

## Antwort

Ja, das **State Pattern** kann ebenfalls mit funktionalen Ansätzen in Java
implementiert werden, ähnlich wie beim Strategy Pattern. Allerdings ist die
Anwendung nicht so direkt und oft weniger intuitiv, da der Zustand (State)
typischerweise mit Daten verknüpft ist, die über die reine Ausführung einer
Methode hinausgehen.

### Die Herausforderungen

Beim traditionellen State Pattern kapselt jede Zustandsklasse nicht nur das
Verhalten, sondern auch den Zustand (die Daten), der das Verhalten beeinflusst.
Die Zustände sind oft voneinander abhängig und wechseln sich gegenseitig ab.

  * **Zustandswechsel:** Die Zustände müssen sich gegenseitig kennen, um den
    Kontext zu aktualisieren und den nächsten Zustand zu setzen. Dies ist mit
    einfachen Lambda-Ausdrücken schwierig abzubilden, da sie keine eigenen
    internen Zustandsvariablen haben, die sie verändern könnten.
  * **Wiederverwendbarkeit:** Die Zustände sind oft nicht unabhängig voneinander.
    Eine `start`-Methode in Zustand A hat eine andere logische Folge als die
    `start`-Methode in Zustand B.

### Ein funktionaler Ansatz

Um das State Pattern funktional zu implementieren, kann man den Zustand als
Parameter übergeben und eine neue Instanz des Zustands zurückgeben.

#### 1. Funktionales Interface für Zustände

Du definierst ein funktionales Interface, das den aktuellen Zustand entgegennimmt und den nächsten Zustand zurückgibt.

```java
@FunctionalInterface
public interface IState {
    IState handle(Context context);
}
```

#### 2. Der Kontext

Der Kontext speichert den aktuellen Zustand und hat eine Methode, um den Zustand zu ändern.

```java
public class Context {
    private IState currentState;

    public Context(IState initialState) {
        this.currentState = initialState;
    }

    public void request() {
        currentState = currentState.handle(this);
    }
}
```

#### 3. Implementierung der Zustände

Die Zustände sind nun Lambda-Ausdrücke, die auf den Kontext zugreifen, um den nächsten Zustand zu setzen.

```java
public class Main {
    public static void main(String[] args) {
        // Die Zustände als finale Variablen definieren, damit sie in den Lambdas verwendet werden können
        final IState initialState = (context) -> {
            System.out.println("Initial State: Handling request. Moving to State 2.");
            return (c) -> {
                System.out.println("State 2: Handling request. Moving back to initial state.");
                return initialState;
            };
        };

        Context context = new Context(initialState);
        context.request(); // Führt initialState aus, wechselt zu State 2
        context.request(); // Führt State 2 aus, wechselt zurück zu initialState
        context.request(); // Führt initialState aus, wechselt zu State 2
    }
}
```

**Fazit:** Der funktionale Ansatz ist beim State Pattern möglich, aber nicht
immer die beste Wahl. Er kann den Code unübersichtlicher machen, da die
Zustandslogik in verschachtelten oder komplexen Lambda-Ausdrücken verborgen
ist. Die traditionelle, objektorientierte Implementierung mit separaten Klassen
ist oft klarer und wartbarer, insbesondere wenn die Zustände komplexer sind und
eigene Daten oder umfangreiche Logik enthalten. Für einfache Zustandsübergänge,
die sich nicht wiederholen, kann dieser Ansatz jedoch eine schnelle und
schlanke Lösung sein.
