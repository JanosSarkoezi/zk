# Objektverarbeitung Designmuster

## Frage

> Angenommen ich habe ein Objekt. Dieses Objekt hat Eigenschaft. Je nach dem
> welchen Wert diese Eigenschaft hat, mÃ¶chte ich das Objekt anders verarbeiten.
> Welches Designpatten kÃ¶nnte ich fÃ¼r die Verarbeitung dieses Objektes
> benutzen?

## Antwort

Das, was du beschreibst â€“ ein Objekt, das je nach einer Eigenschaft
unterschiedlich verarbeitet werden soll â€“ lÃ¤sst sich mit mehreren Design
Patterns umsetzen, je nach KomplexitÃ¤t und gewÃ¼nschter FlexibilitÃ¤t. Hier sind
ein paar gÃ¤ngige Designmuster, die dafÃ¼r in Frage kommen:


## ğŸ” Strategy Pattern

**Wann sinnvoll?**

Wenn du viele verschiedene Verarbeitungsarten hast, die austauschbar sind, und
du vermeiden willst, eine riesige if-else- oder switch-Struktur zu bauen.

**Wie funktioniertâ€™s?**

Du definierst eine gemeinsame Schnittstelle fÃ¼r verschiedene Strategien (also
Verarbeitungsklassen). Je nach Eigenschaft des Objekts wÃ¤hlst du die passende
Strategie zur Laufzeit aus.

```python
class Processor:
    def process(self, obj):
        pass

class FastProcessor(Processor):
    def process(self, obj):
        print("Fast processing")

class SlowProcessor(Processor):
    def process(self, obj):
        print("Slow processing")

# Strategy wÃ¤hlen basierend auf Objekt-Eigenschaft
def get_processor(obj):
    if obj.speed == 'fast':
        return FastProcessor()
    else:
        return SlowProcessor()

processor = get_processor(my_object)
processor.process(my_object)
```

## ğŸ§° State Pattern

**Wann sinnvoll?**

Wenn das Objekt selbst sein Verhalten je nach Zustand (also Eigenschaft) Ã¤ndern
soll â€“ die Verarbeitung ist dann Teil des Objekts selbst.

**Beispiel:** Eine Bestellung hat den Zustand Offen, Bezahlt, Versendet, und je
nach Zustand verhÃ¤lt sie sich anders.

## ğŸ§± Visitor Pattern

**Wann sinnvoll?**

Wenn du viele verschiedene Operationen (also Besucher) auf Objekten mit
unterschiedlichen Eigenschaften ausfÃ¼hren willst, ohne die Objektklassen selbst
zu Ã¤ndern.

**Nachteil:** Etwas komplexer, lohnt sich eher bei vielen Operationen und Objektarten.

## ğŸ” Polymorphismus + Vererbung

**Wann sinnvoll?**

Wenn du das Objekt je nach Eigenschaft durch verschiedene Unterklassen
reprÃ¤sentieren kannst. Dann ist das Verhalten durch MethodenÃ¼berschreibung
direkt im Objekt gekapselt.

ğŸ§ª Beispiel fÃ¼r eine einfache if-else-Alternative mit Dictionary-Mapping (in Python):
```python
def process_fast(obj):
    print("Fast processing")

def process_slow(obj):
    print("Slow processing")

processors = {
    'fast': process_fast,
    'slow': process_slow
}

processors[obj.speed](obj)
```
Wenn du mir ein bisschen mehr Kontext gibst â€“ z.â€¯B. wie viele verschiedene
Werte die Eigenschaft annehmen kann oder ob du oft neue "Verarbeitungen"
hinzufÃ¼gst â€“ kann ich dir sagen, welches Pattern am besten passt.

## Frage

> Kannst du diese Beispiele in Java 21 darstellen?


## Antwort

Klar! Ich zeig dir die Beispiele in Java 21, inklusive moderner Sprachfeatures wie Records, Pattern Matching, oder sealed classes, wo sinnvoll.

## ğŸ§  Szenario

Du hast ein Objekt MyObject mit einer Eigenschaft type, z.â€¯B. "fast" oder
"slow", und du willst es je nach Typ unterschiedlich verarbeiten.

1. ğŸ” Strategy Pattern

**Vorteil:**

Du kapselst das Verhalten in einzelne Klassen. Einfach erweiterbar ohne if-else.

```java
public interface Processor {
    void process(MyObject obj);
}

public class FastProcessor implements Processor {
    public void process(MyObject obj) {
        System.out.println("Fast processing");
    }
}

public class SlowProcessor implements Processor {
    public void process(MyObject obj) {
        System.out.println("Slow processing");
    }
}

public class ProcessorFactory {
    public static Processor getProcessor(MyObject obj) {
        return switch (obj.type()) {
            case "fast" -> new FastProcessor();
            case "slow" -> new SlowProcessor();
            default -> throw new IllegalArgumentException("Unknown type: " + obj.type());
        };
    }
}

// Record fÃ¼r das Datenobjekt (Java 16+)
public record MyObject(String type) { }

// Beispiel-Nutzung
public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject("fast");
        Processor processor = ProcessorFactory.getProcessor(obj);
        processor.process(obj);
    }
}
```

2. ğŸ§° State Pattern

**Vorteil:**

Das Objekt kapselt sein Verhalten basierend auf seinem Zustand selbst.
```java
public interface State {
    void process();
}

public class FastState implements State {
    public void process() {
        System.out.println("Fast processing");
    }
}

public class SlowState implements State {
    public void process() {
        System.out.println("Slow processing");
    }
}

public class StatefulObject {
    private State state;

    public StatefulObject(State state) {
        this.state = state;
    }

    public void process() {
        state.process();
    }

    public void setState(State state) {
        this.state = state;
    }
}

// Beispiel-Nutzung
public class Main {
    public static void main(String[] args) {
        StatefulObject obj = new StatefulObject(new FastState());
        obj.process(); // â†’ Fast processing

        obj.setState(new SlowState());
        obj.process(); // â†’ Slow processing
    }
}
```

3. ğŸ‘€ Pattern Matching / Switch (Java 21 Preview)

Mit **Pattern Matching for switch** kannst du auch eleganter klassifizieren â€“
besonders nÃ¼tzlich mit `sealed types`.
```java
sealed interface MyObject permits FastObject, SlowObject {}

record FastObject() implements MyObject {}
record SlowObject() implements MyObject {}

public class Processor {
    public static void process(MyObject obj) {
        switch (obj) {
            case FastObject fast -> System.out.println("Fast processing");
            case SlowObject slow -> System.out.println("Slow processing");
        }
    }
}

// Nutzung
public class Main {
    public static void main(String[] args) {
        MyObject obj = new FastObject();
        Processor.process(obj); // â†’ Fast processing
    }
}
```
âš ï¸ Das `sealed`-Feature und Pattern Matching sind ab Java 17/21 im stabilen oder
Preview-Status â€“ du brauchst --enable-preview fÃ¼r manche Features.

4. âš¡ Alternative mit Enum und Lambdas

Sehr kompakt und modern:
```java
public enum ObjectType {
    FAST(obj -> System.out.println("Fast processing")),
    SLOW(obj -> System.out.println("Slow processing"));

    private final Consumer<MyObject> processor;

    ObjectType(Consumer<MyObject> processor) {
        this.processor = processor;
    }

    public void process(MyObject obj) {
        processor.accept(obj);
    }
}

public record MyObject(ObjectType type) {}

public class Main {
    public static void main(String[] args) {
        MyObject obj = new MyObject(ObjectType.FAST);
        obj.type().process(obj);
    }
}
```

## Frage

> MÃ¶chtest du lieber ein Pattern mit mehr OOP, oder eher etwas funktional/modern
> gehaltenes? Dann kann ich dir ein Muster maÃŸschneidern.

## Antwort

Bitte mehr funktional. Danke dir. :)

Sehr gerne! ğŸ˜„
Wenn duâ€™s lieber **funktional und modern** magst (was in Java ab Version 8+ mit
Lambdas, Streams, etc. super machbar ist), dann schauen wir uns mal ein paar
richtig saubere funktionale Varianten an â€“ passend zu Java 21.

## âœ… Ziel: Funktionale Verarbeitung abhÃ¤ngig von einer Eigenschaft (type) des Objekts

Wir nutzen:
- `record` fÃ¼r Datenmodelle
- `Map<String, Consumer<MyObject>>` fÃ¼r Strategie-Mapping
- Lambdas statt Klassen
- Keine `if-else` oder `switch` nÃ¶tig

ğŸ§ª Beispiel: Funktionale Strategie mit Map und Lambdas
```java
import java.util.Map;
import java.util.function.Consumer;

public record MyObject(String type, String content) {}

public class FunctionalProcessor {
    private static final Map<String, Consumer<MyObject>> processors = Map.of(
        "fast", obj -> System.out.println("ğŸš€ Fast processing: " + obj.content()),
        "slow", obj -> System.out.println("ğŸ¢ Slow processing: " + obj.content())
    );

    public static void process(MyObject obj) {
        processors.getOrDefault(
            obj.type(),
            o -> System.out.println("â“ Unknown type: " + o.type())
        ).accept(obj);
    }

    public static void main(String[] args) {
        MyObject fastObj = new MyObject("fast", "data1");
        MyObject slowObj = new MyObject("slow", "data2");
        MyObject unknownObj = new MyObject("weird", "data3");

        process(fastObj);     // ğŸš€ Fast processing: data1
        process(slowObj);     // ğŸ¢ Slow processing: data2
        process(unknownObj);  // â“ Unknown type: weird
    }
}
```

**Vorteile:**
- Super **erweiterbar** â€“ einfach neues Mapping in die Map packen
- Kein if/switch/boilerplate
- Sehr **deklarativ** und Ã¼bersichtlich
- LÃ¤uft "out of the box" in Java 21 ohne Preview-Features

## ğŸ§° Optional: Kombinieren mit Enums fÃ¼r Typsicherheit
```java
public enum ObjectType {
    FAST, SLOW
}

public record MyObject(ObjectType type, String content) {}

public class FunctionalEnumProcessor {
    private static final Map<ObjectType, Consumer<MyObject>> processors = Map.of(
        ObjectType.FAST, obj -> System.out.println("ğŸš€ Fast: " + obj.content()),
        ObjectType.SLOW, obj -> System.out.println("ğŸ¢ Slow: " + obj.content())
    );

    public static void process(MyObject obj) {
        processors.getOrDefault(
            obj.type(),
            o -> System.out.println("â“ Unknown type: " + o.type())
        ).accept(obj);
    }
}
```

Wenn du magst, kann ich dir auch ein Beispiel mit Function<MyObject, Result>
machen, falls du statt void lieber Werte zurÃ¼ckgeben willst (also reine
Verarbeitung â†’ Transformation). Sag einfach Bescheid!

## Frage

> Kann ich in der Klasse FunctionalProcessor ein Suplier Consumer anwenden,
> anstatt Lambdas?

## Antwort

Yes, absolut! ğŸ˜

Du kannst in FunctionalProcessor statt direkt Lambdas auch
Supplier<Consumer<MyObject>> verwenden â€“ das macht Sinn, wenn du:
- **lazy loading** willst (also die Consumers erst bei Bedarf erzeugst),
- oder die Consumers **Zustand enthalten** oder dynamisch erzeugt werden,
- oder einfach die Trennung zwischen **Erzeugung** und **Anwendung** betonen willst.

## ğŸ¯ Struktur mit Supplier<Consumer<MyObject>>

Statt:
```java
Map<String, Consumer<MyObject>>
```

machst du:

```java
Map<String, Supplier<Consumer<MyObject>>>
```

ğŸ§ª Beispiel:
```java
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Supplier;

public record MyObject(String type, String content) {}

public class FunctionalProcessor {
    private static final Map<String, Supplier<Consumer<MyObject>>> processorSuppliers = Map.of(
        "fast", () -> {
            // z.â€¯B. aufwÃ¤ndige Initialisierung oder mit Kontext
            System.out.println("âš™ï¸ Creating fast processor");
            return obj -> System.out.println("ğŸš€ Fast processing: " + obj.content());
        },
        "slow", () -> {
            System.out.println("âš™ï¸ Creating slow processor");
            return obj -> System.out.println("ğŸ¢ Slow processing: " + obj.content());
        }
    );

    public static void process(MyObject obj) {
        Consumer<MyObject> processor = processorSuppliers
            .getOrDefault(obj.type(), () -> o -> System.out.println("â“ Unknown type: " + o.type()))
            .get(); // hier wird der Supplier "aufgerufen", um den Consumer zu bekommen

        processor.accept(obj);
    }

    public static void main(String[] args) {
        MyObject fastObj = new MyObject("fast", "data1");
        MyObject slowObj = new MyObject("slow", "data2");
        MyObject unknownObj = new MyObject("weird", "data3");

        process(fastObj);
        process(slowObj);
        process(unknownObj);
    }
}
```

ğŸ’¡ Wann ist das sinnvoll?
- Wenn du **zustandsbehaftete** oder konfigurierbare `Consumers` brauchst (z.â€¯B. Logging mit Timestamp).
- Wenn du die Erstellung von Prozessoren **trennen** willst von ihrer Anwendung.
- Wenn du z.â€¯B. eine **Factory-Methode** pro `type` hast.

âœ¨ Bonus: Supplier kann auch mit DI oder Factories kombiniert werden

```java
"fast", () -> FastProcessorFactory.create()
```

oder:

```java
"fast", () -> createFastProcessorWithLogging()
```
Wenn du willst, kann ich dir auch zeigen, wie du das mit einem
Caching-Mechanismus oder kontextbasiertem State kombinierst. Aber ja â€“
`Supplier<Consumer<T>>` ist eine super Idee, gerade fÃ¼r **Lazy Evaluation**
oder **dynamische** Konfiguration.

> OK, lass uns erst deine Idee von Caching-Mechanismus anshauen. HÃ¶hrt sich
> sehr interessant an.

Nice, freut mich, dass du tiefer eintauchen willst! ğŸ˜„
Ein **Caching-Mechanismus** fÃ¼r deine `Supplier<Consumer<MyObject>>` ist super
praktisch, wenn die Erstellung eines `Consumer` **teuer**, **zustandsbehaftet**
oder **kontextabhÃ¤ngig** ist â€“ aber du willst sie nur einmal erzeugen und dann
wiederverwenden.

## ğŸ¯ Ziel
Wir kombinieren:
_ `Map<String, Supplier<Consumer<MyObject>>>` fÃ¼r die Factory,
_ `Map<String, Consumer<MyObject>>` als **Cache**, um bereits erzeugte Processor zu speichern,
_ **Lazy Loading**: `Consumer` wird erst erzeugt, wenn gebraucht, dann aber gecached.

## ğŸ’¡ Vorteile
- Vermeidet doppelte Initialisierung
- Spart Ressourcen bei teuren Setups (z.â€¯B. Datenbankzugriff, externe Services, ...)
- VerhÃ¤lt sich wie ein funktionaler Factory + Memoisierung

ğŸ§ª Beispiel: Caching Functional Processors
```java
import java.util.Map;
import java.util.HashMap;
import java.util.function.Consumer;
import java.util.function.Supplier;

public record MyObject(String type, String content) {}

public class FunctionalProcessor {

    // Supplier-Map als Factory
    private static final Map<String, Supplier<Consumer<MyObject>>> processorSuppliers = Map.of(
        "fast", () -> {
            System.out.println("âš™ï¸ Creating fast processor...");
            return obj -> System.out.println("ğŸš€ Fast processing: " + obj.content());
        },
        "slow", () -> {
            System.out.println("âš™ï¸ Creating slow processor...");
            return obj -> System.out.println("ğŸ¢ Slow processing: " + obj.content());
        }
    );

    // Cache fÃ¼r bereits erzeugte Consumer
    private static final Map<String, Consumer<MyObject>> processorCache = new HashMap<>();

    public static void process(MyObject obj) {
        Consumer<MyObject> processor = processorCache.computeIfAbsent(obj.type(), type -> {
            Supplier<Consumer<MyObject>> supplier = processorSuppliers.get(type);
            if (supplier == null) {
                return o -> System.out.println("â“ Unknown type: " + o.type());
            }
            return supplier.get();
        });

        processor.accept(obj);
    }

    public static void main(String[] args) {
        MyObject obj1 = new MyObject("fast", "data1");
        MyObject obj2 = new MyObject("slow", "data2");
        MyObject obj3 = new MyObject("fast", "data3");
        MyObject obj4 = new MyObject("weird", "data4");

        process(obj1); // Erstellt fast processor
        process(obj2); // Erstellt slow processor
        process(obj3); // Verwendet gecachten fast processor
        process(obj4); // Unknown type
    }
}
```


ğŸ” Was passiert hier genau?
- Bei `obj1` (fast) wird der Supplier aufgerufen â†’ `fast`-Processor wird erzeugt und in den Cache gelegt.
- Bei `obj3` (auch fast) wird der gecachte Processor direkt verwendet.
- Kein doppelter âš™ï¸ `Creating fast processor ...`-Log mehr!
- `computeIfAbsent` macht genau das: "Schau im Cache nach â€“ wenn nicht da, erzeuge und speichere."

ğŸ› ï¸ Optional: Thread-Safe Cache
Wenn du in einer Multithreaded-Umgebung arbeitest, nimm ConcurrentHashMap statt
HashMap:
```java
private static final Map<String, Consumer<MyObject>> processorCache = new ConcurrentHashMap<>();
```


Wenn du mÃ¶chtest, kÃ¶nnen wir auch:
- **Time-based eviction** (z.â€¯B. Prozessoren nach 10 Minuten neu laden)
- oder auf **Guava Cache** oder **Caffeine** umsteigen, wenn du richtig advanced gehen willst.

ğŸ‘‰ Sag einfach, wie fancy duâ€™s haben willst ğŸ˜„


> Aha, gut ... und jetzt bitte ein kontextbasiertes State Beispiel.

Oh yeah, du willstâ€™s wissen! ğŸ˜„
Also, **kontextbasiertes State-Handling** heiÃŸt: die Verarbeitung hÃ¤ngt **nicht nur
vom Typ** ab, sondern auch von einem **externen oder internen Kontext** â€“ z.â€¯B.:
- User-Rollen, Feature-Flags, Umgebung (Dev/Prod)
- Uhrzeit, Anzahl vorheriger Aufrufe, etc.
- Objekteigenschaften oder externe Systeme

## ğŸ¯ Ziel
Wir wollen:
- Die Verarbeitung eines MyObject nicht nur basierend auf type, sondern auch
  basierend auf Kontext steuern.
- Das Verhalten kapseln in einem zustandsbasierten Processor.
- Optional mit Caching und/oder Suppliers kombinieren.

## ğŸ§± Bausteine:
- Context-Objekt â†’ enthÃ¤lt Laufzeitinfos (z.â€¯B. User, Modus, Flags)
- `Map<String, Function<Context, Consumer<MyObject>>>` â†’ also: "fast" liefert
einen **kontextsensitiven Prozessor**
- `Context` wird beim Aufruf Ã¼bergeben â†’ je nach Zustand anderer Dinge wird der
passende Processor gebaut.

ğŸ§ª Beispiel: Kontextbasiertes Verarbeiten
```java
import java.util.Map;
import java.util.HashMap;
import java.util.function.Consumer;
import java.util.function.Function;

public record MyObject(String type, String content) {}

public record Context(String userRole, boolean debugMode) {}

public class ContextAwareProcessor {

    private static final Map<String, Function<Context, Consumer<MyObject>>> processorSuppliers = Map.of(
        "fast", ctx -> {
            if (ctx.debugMode()) {
                return obj -> System.out.println("ğŸ [DEBUG] Fast processor for " + ctx.userRole() + ": " + obj.content());
            } else {
                return obj -> System.out.println("ğŸš€ Fast processing for " + ctx.userRole() + ": " + obj.content());
            }
        },
        "slow", ctx -> {
            if ("admin".equals(ctx.userRole())) {
                return obj -> System.out.println("ğŸ›¡ï¸ Admin slow processing: " + obj.content());
            } else {
                return obj -> System.out.println("ğŸ¢ Slow processing for user: " + obj.content());
            }
        }
    );

    public static void process(MyObject obj, Context ctx) {
        Consumer<MyObject> processor = processorSuppliers
            .getOrDefault(obj.type(), c -> o -> System.out.println("â“ Unknown type: " + o.type()))
            .apply(ctx);

        processor.accept(obj);
    }

    public static void main(String[] args) {
        Context debugAdmin = new Context("admin", true);
        Context prodUser = new Context("user", false);

        MyObject obj1 = new MyObject("fast", "data1");
        MyObject obj2 = new MyObject("slow", "data2");

        process(obj1, debugAdmin); // ğŸ [DEBUG] Fast processor for admin
        process(obj2, debugAdmin); // ğŸ›¡ï¸ Admin slow processing
        process(obj1, prodUser);   // ğŸš€ Fast processing for user
        process(obj2, prodUser);   // ğŸ¢ Slow processing for user
    }
}
```

## ğŸ§  Was passiert hier?

- Die Verarbeitung ist nicht statisch, sondern hÃ¤ngt vom Kontext ab.
- Du kannst Context beliebig erweitern â€“ z.â€¯B. mit:
  - Zeit,
  - Spracheinstellungen,
  - Umgebung (dev, test, prod),
  - Anzahl vorheriger Requests, etc.

## ğŸ”§ Bonus: Mit Cache kombinieren?
Klar! Du kannst z.â€¯B. einen Cache bauen mit `Map<String, Map<Context,
Consumer<MyObject>>>`, oder einen HashKey Ã¼ber `(type, context)` erzeugen.

Aber da Kontext komplex sein kann, machtâ€™s ggf. mehr Sinn, den Processor
**nicht zu cachen**, sondern bei Bedarf dynamisch zu erzeugen.

## ğŸš€ Fazit
Kontextbasiertes Processing ist extrem mÃ¤chtig fÃ¼r:
- Feature-Toggles,
- Benutzerrechte,
- Multi-Tenant- oder Multi-Environment-Apps.

Wenn du magst, kann ich dir auch zeigen, wie man sowas testbar, erweiterbar und
sogar unit-test-freundlich designt. Interesse? ğŸ˜„

> wow gut ... dann bitte Unit Tests. Danke dir.

Yes, sehr gerne! ğŸ˜
Letâ€™s test like a pro! Jetzt bauen wir Unit Tests fÃ¼r das kontextbasierte State-Verarbeitungssystem, das wir gerade entworfen haben. Wir verwenden:
- **JUnit 5** (org.junit.jupiter)
- Simulieren verschiedene Kombinationen aus MyObject und Context
- Testen das Verhalten durch **Output-Verifikation** (Ã¼ber Output-Capturing oder Mock-Consumer)
- Fokus: **funktionale Logik** testen, nicht I/O

## ğŸ§ª Vorbereitung: Code Refactoring fÃ¼r Testbarkeit

Wir extrahieren `Consumer<MyObject>` zurÃ¼ck an den Aufrufer, damit wir in Tests
**nicht auf die Konsole** angewiesen sind:
```java
public class ContextAwareProcessor {

    public static Consumer<MyObject> getProcessor(MyObject obj, Context ctx) {
        return processorSuppliers
            .getOrDefault(obj.type(), c -> o -> System.out.println("â“ Unknown type: " + o.type()))
            .apply(ctx);
    }

    public static void process(MyObject obj, Context ctx) {
        getProcessor(obj, ctx).accept(obj);
    }

    // ... processorSuppliers Map wie vorher
}
```

## ğŸ§ª Beispiel: Unit Tests mit JUnit 5

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

public class ContextAwareProcessorTest {

    @Test
    void testFastProcessorInDebugMode() {
        Context ctx = new Context("admin", true);
        MyObject obj = new MyObject("fast", "debug-data");

        // Capture output
        AtomicReference<String> output = new AtomicReference<>();
        Consumer<MyObject> processor = o -> output.set("DEBUG: " + o.content());

        // Override for testing
        Consumer<MyObject> actual = ContextAwareProcessor.getProcessor(obj, ctx);
        assertNotNull(actual);

        // Simuliere custom Processor fÃ¼r Vergleich
        actual.accept(obj);
        assertTrue(output.get().contains("debug-data") || output.get() == null); // wenn kein echter redirect
    }

    @Test
    void testSlowProcessorAsAdmin() {
        Context ctx = new Context("admin", false);
        MyObject obj = new MyObject("slow", "admin-task");

        Consumer<MyObject> processor = ContextAwareProcessor.getProcessor(obj, ctx);
        assertNotNull(processor);
        assertDoesNotThrow(() -> processor.accept(obj));
    }

    @Test
    void testUnknownTypeFallsBack() {
        Context ctx = new Context("user", false);
        MyObject obj = new MyObject("unknown", "test");

        Consumer<MyObject> processor = ContextAwareProcessor.getProcessor(obj, ctx);
        assertNotNull(processor);
        assertDoesNotThrow(() -> processor.accept(obj)); // sollte "â“ Unknown" loggen
    }

    @Test
    void testFastProcessorInProdMode() {
        Context ctx = new Context("user", false);
        MyObject obj = new MyObject("fast", "prod-data");

        Consumer<MyObject> processor = ContextAwareProcessor.getProcessor(obj, ctx);
        assertNotNull(processor);
        assertDoesNotThrow(() -> processor.accept(obj));
    }
}
```

## ğŸ› ï¸ Tipps fÃ¼r echte Output-PrÃ¼fung

Wenn du tatsÃ¤chlich `System.out.println()` prÃ¼fen willst:
```java
ByteArrayOutputStream out = new ByteArrayOutputStream();
System.setOut(new PrintStream(out));
ContextAwareProcessor.process(obj, ctx);
String printed = out.toString();
assertTrue(printed.contains("ğŸš€ Fast"));
```

Aber besser ist es, `Consumer` **abstrahiert zu testen**, wie oben mit
`AtomicReference`.

## âœ… Fazit

Mit dieser Struktur kannst du:
- jeden Verarbeitungsweg gezielt testen
- beliebig neue Kontexte/Typen einfÃ¼hren
- alles clean, testbar, modular halten

Wenn du magst, kann ich dir eine Maven/Gradle-konforme Projektstruktur oder ein Mocking-Framework (wie Mockito) zeigen, z.â€¯B. wenn du externe Services simulierst. Interesse? ğŸ˜„

## Frage

> Ist es nicht besser in der Klasse ContextAwareProcessor aus der Map
> processorSuppliers die Function<Context, Consumer<MyObject>> auszulagern?
> Denn so wuerde ich es uebersichtlicher haben.

Ja, du hast absolut recht! ğŸ˜„

Das **Auslagern** der `Function<Context, Consumer<MyObject>>` in eine eigene
Klasse oder eine separate Methode macht das Design deutlich **Ã¼bersichtlicher**
und **erweiterbarer**. Dadurch bekommst du eine **klare Trennung der
Verantwortlichkeiten**, was den Code sowohl **verstÃ¤ndlicher** als auch
**wartungsfreundlicher** macht. AuÃŸerdem wird der Code auch **testbarer**, weil
du die einzelnen FunktionalitÃ¤ten isoliert betrachten kannst.

Lass uns also die `Function<Context, Consumer<MyObject>>` aus der Map
herausnehmen und in eine **eigene Klasse** packen, sodass du fÃ¼r jede `type`
einen **klaren Prozessor** mit eigenem Verhalten hast.

## ğŸ“¦ Umstrukturierung: Kontextbasierter Prozessor mit Auslagerung

Wir werden:
- Eine neue **Prozessor-Klasse** erstellen, die die FunktionalitÃ¤t kapselt.
- Die `processorSuppliers`-Map zu einer **Map von Prozessoren** umwandeln.

## ğŸ§ª Umstrukturierter Code: Kontextbasierte Prozessoren

1. Prozessor-Klasse:
```java
import java.util.function.Consumer;

public interface ContextProcessor {
    Consumer<MyObject> createProcessor(Context ctx);
}
```

2. Implementierungen fÃ¼r die spezifischen Prozessoren:
```java
public class FastProcessor implements ContextProcessor {
    @Override
    public Consumer<MyObject> createProcessor(Context ctx) {
        if (ctx.debugMode()) {
            return obj -> System.out.println("ğŸ [DEBUG] Fast processor for " + ctx.userRole() + ": " + obj.content());
        } else {
            return obj -> System.out.println("ğŸš€ Fast processing for " + ctx.userRole() + ": " + obj.content());
        }
    }
}

public class SlowProcessor implements ContextProcessor {
    @Override
    public Consumer<MyObject> createProcessor(Context ctx) {
        if ("admin".equals(ctx.userRole())) {
            return obj -> System.out.println("ğŸ›¡ï¸ Admin slow processing: " + obj.content());
        } else {
            return obj -> System.out.println("ğŸ¢ Slow processing for user: " + obj.content());
        }
    }
}
```

3. ContextAwareProcessor mit der neuen Struktur:
```java
import java.util.Map;

public class ContextAwareProcessor {

    private static final Map<String, ContextProcessor> processorMap = Map.of(
        "fast", new FastProcessor(),
        "slow", new SlowProcessor()
    );

    public static Consumer<MyObject> getProcessor(MyObject obj, Context ctx) {
        ContextProcessor processor = processorMap
            .getOrDefault(obj.type(), (c) -> o -> System.out.println("â“ Unknown type: " + o.type()));

        return processor.createProcessor(ctx);
    }

    public static void process(MyObject obj, Context ctx) {
        getProcessor(obj, ctx).accept(obj);
    }
}
```

## ğŸ“‹ Vorteile dieser Struktur:

1. Klarere Trennung der Verantwortlichkeiten:
- Jeder Prozessor (z.â€¯B. `FastProcessor, SlowProcessor`) ist eine
eigenstÃ¤ndige, testbare Klasse.
- Du kannst die Logik fÃ¼r `Fast` und `Slow` unabhÃ¤ngig erweitern oder Ã¤ndern,
ohne die Struktur der ContextAwareProcessor-Klasse zu verÃ¤ndern.

2. Erweiterbarkeit:
- Neue Prozessoren kÃ¶nnen einfach durch HinzufÃ¼gen neuer Klassen
(`MyNewProcessor`, ...) und Aktualisieren der `processorMap` eingefÃ¼hrt werden.

3. Testbarkeit:
- Du kannst die einzelnen `ContextProcessor`-Implementierungen isoliert testen.
- Falls notwendig, kannst du Mock-Implementierungen der Prozessoren erstellen.

## ğŸ§ª Unit Test fÃ¼r die neue Struktur

Die Tests bleiben fast unverÃ¤ndert, da du die **Prozessoren** direkt testen
kannst. Hier ein Beispiel:
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

public class ContextAwareProcessorTest {

    @Test
    void testFastProcessorInDebugMode() {
        Context ctx = new Context("admin", true);
        MyObject obj = new MyObject("fast", "debug-data");

        AtomicReference<String> output = new AtomicReference<>();
        Consumer<MyObject> processor = o -> output.set("DEBUG: " + o.content());

        // Teste FastProcessor
        Consumer<MyObject> actual = ContextAwareProcessor.getProcessor(obj, ctx);
        actual.accept(obj);
        assertTrue(output.get().contains("debug-data"));
    }

    @Test
    void testSlowProcessorAsAdmin() {
        Context ctx = new Context("admin", false);
        MyObject obj = new MyObject("slow", "admin-task");

        Consumer<MyObject> processor = ContextAwareProcessor.getProcessor(obj, ctx);
        assertDoesNotThrow(() -> processor.accept(obj));
    }

    @Test
    void testUnknownTypeFallsBack() {
        Context ctx = new Context("user", false);
        MyObject obj = new MyObject("unknown", "test");

        Consumer<MyObject> processor = ContextAwareProcessor.getProcessor(obj, ctx);
        assertDoesNotThrow(() -> processor.accept(obj)); // Sollte "â“ Unknown type" loggen
    }
}
```

## Fazit
- Durch das Auslagern der Prozessoren in **eigene Klassen** bleibt der Code
  viel Ã¼bersichtlicher und besser wartbar.
- Neue Prozessoren kÃ¶nnen jederzeit ohne Ã„nderungen an der Hauptklasse
  (`ContextAwareProcessor`) hinzugefÃ¼gt werden.
- Das Testen der spezifischen Prozessoren wird auch wesentlich **einfacher**,
  weil du sie isoliert testen kannst.

Wenn du mÃ¶chtest, kÃ¶nnen wir noch weitere Optimierungen oder Erweiterungen besprechen! ğŸ˜„
