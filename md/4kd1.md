# Datenweitergabe in Java Either-Ketten

## Frage

Soweit ich weiss, sie eine Klasse Either geeignet fuer die Verkettung
sequenzieller Ablaeufe. Wenn ein Fehlerfall in dieser Kette passiert, dann
bricht die Verarbeutung der Kette ab. Was ist die beste moeglichkeit bestimmte
Daten in dieser Kette weiterzureichen? Ich denke dabei an Java 21.

## Antwort

Das ist eine ausgezeichnete Frage und Sie haben die Funktionalität des **Either-Monads** (oder ähnlicher **Result-Typen**) für sequentielle Fehlerbehandlung sehr gut erkannt.

Die **beste Möglichkeit**, um bestimmte Daten in dieser Kette in Java 21 weiterzureichen, hängt davon ab, **welche Art von Daten** Sie weitergeben möchten und **wie sich diese Daten zur erfolgreichen oder fehlerhaften Verarbeitung verhalten**.

Da Java keine native `Either`-Klasse hat (im Gegensatz zu `Optional`), verwendet man in der Praxis oft:

1.  **Bibliotheken** (z. B. **Vavr** mit `io.vavr.control.Either`).
2.  Eine **eigene Implementierung** (oft als **Sealed Interface** oder **Records** in Java 17+ / 21) .

Unabhängig von der Implementierung sind die wichtigsten Techniken zur **Datenweitergabe** in der Kette die Verwendung der Funktionen **`map`** und **`flatMap`** auf der Erfolgsseite (`Right`).

-----

## 1\. Weitergabe des aktuellen erfolgreichen Wertes

Der Hauptmechanismus zur Weitergabe des **Erfolgswertes** (`Right`) in der Kette ist die **monadische Kette** selbst:

  * **`map(Function<R, R2> f)`:**

      * Wird verwendet, um den erfolgreichen Wert (`R`) zu **transformieren** (`R2`), ohne dass dieser Schritt fehlschlagen kann (er muss immer einen erfolgreichen Wert zurückgeben).
      * **Verwendung:** Wenn Sie den *aktuellen* Wert (z. B. eine ID) ändern, berechnen oder konvertieren, um ihn für den nächsten Schritt vorzubereiten. Der nächste Schritt arbeitet dann mit dem neuen Wert (`R2`).

  * **`flatMap(Function<R, Either<L, R2>> f)`:**

      * Wird verwendet, um eine Funktion anzuwenden, die **selbst ein neues `Either`-Objekt zurückgibt** (d. h. der nächste Schritt kann fehlschlagen).
      * **Verwendung:** Dies ist der Standardmechanismus, um sequentielle Abläufe zu verketten. Wenn der aktuelle `Either` ein `Right(R)` ist, wird die Funktion angewendet und der resultierende `Either<L, R2>` wird zurückgegeben. Wenn der aktuelle `Either` ein `Left(L)` ist, wird die Kette angehalten und das `Left(L)` unverändert weitergegeben.

### Beispiel (mit Vavr-Syntax oder ähnlicher Custom-Implementierung):

```java
Either<Error, User> result = validateInput(input)
    .flatMap(validated -> fetchUser(validated.userId())) // Weitergabe des Erfolgs "validated"
    .map(user -> user.toDTO()); // Transformation des Erfolgs "user" zu einem DTO
```

-----

## 2\. Weitergabe von *zusätzlichem* Status oder Kontextdaten

Manchmal müssen Sie nicht nur den Erfolgswert des *letzten* Schrittes, sondern auch **zusätzliche Kontextdaten** oder **Ergebnisse früherer Schritte** weitergeben, die für spätere Schritte wichtig sind.

Die beste Methode dafür, ohne die Kette zu unterbrechen, besteht darin, ein **neues Record-Objekt** (seit Java 16+) als Wert der **`Right`**-Seite zu definieren:

### 1\. Verwendung eines Records (empfohlen)

Sie definieren für jeden Schritt (oder eine Gruppe von Schritten) einen **Record**, der alle benötigten Daten bündelt.

```java
// Records zur Bündelung der Daten
record InitialContext(String rawInput, int parsedId) {}
record ProcessedData(InitialContext context, User user, boolean isNew) {}
record FinalResult(String outputMessage) {}
```

### 2\. Kette mit Records

In jedem **`flatMap`**-Schritt *erweitern* Sie das Record-Objekt mit den neu gewonnenen Informationen oder erstellen ein neues Record, das die relevanten alten Daten enthält.

```java
Either<Error, FinalResult> finalResult = 
    parseInput(rawString) // -> Either<Error, InitialContext>
    .flatMap(context -> fetchAndProcess(context) // context enthält 'rawInput' und 'parsedId'
        // fetchAndProcess muss nun Either<Error, ProcessedData> zurückgeben,
        // wobei ProcessedData (context, user, isNew) enthält.
    )
    .map(data -> createMessage(data)) // data enthält alle Zwischenschritte
    // createMessage muss nun FinalResult zurückgeben.
    
```

### Vorteil des Records:

  * **Explizitheit:** Es ist sofort ersichtlich, welche Daten jeder Schritt benötigt und welche Daten er weitergibt.
  * **Immutable:** Records sind standardmäßig unveränderlich (immutable), was ideal für funktionale Programmierung und das Vermeiden von Side Effects ist.
  * **Java 21-konform:** Records sind seit Java 16 (und stabil in Java 17) ein modernes Sprachfeature.

-----

## 3\. Empfehlenswerte Java-Implementierungen

Da Sie Java 21 verwenden, sollten Sie sich eine der folgenden Optionen ansehen, da sie **`Either`** oder ähnliche **Result-Typen** mit den Funktionen `map` und `flatMap` bereitstellen:

  * **Vavr Library:** Bietet eine vollwertige `io.vavr.control.Either` Implementierung, die sehr idiomatisch für diesen Stil ist. (Am häufigsten verwendet).
  * **Custom Sealed Interface/Record:** Eine schlankere, native Lösung ohne externe Abhängigkeit, die die gleichen Vorteile bietet. Hier ein stark vereinfachter Entwurf in Java 21:

<!-- end list -->

```java
// Rudimentäre, native Java 21 Either-Implementierung
public sealed interface Result<E, T> permits Result.Error, Result.Success {
    // ... map, flatMap Methoden hier definieren
    
    record Success<E, T>(T value) implements Result<E, T> {}
    record Error<E, T>(E error) implements Result<E, T> {}
}
```

**Fazit:** Nutzen Sie **Records** als den Erfolgswert (`Right`) Ihrer `Either`-Klasse, um alle benötigten Kontext- und Zwischenergebnisse explizit und typsicher zu bündeln und über **`flatMap`** an die nächsten Schritte weiterzugeben.
