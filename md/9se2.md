# Typisierter Container in Java

## Frage

> Angenommen ich habe zwei Objete, `Document` (d) und `DocumentAttribute` (da). Ich
> moechte einen `Container` aufbauen, in der das d und eine Liste von da sind.
> Gibt es in Java eine typisierbare Container-Klasse? Meine sowas wie
> `Container<Document>`?

## Antwort

Ja, in Java kannst du dir einen typisierten Container ganz einfach selbst
erstellen ‚Äì das ist ein g√§ngiges Muster, besonders wenn du eine bestimmte
Kombination von Objekten b√ºndeln m√∂chtest (z.‚ÄØB. ein Document und eine Liste
von DocumentAttribute). Java bietet zwar generische Klassen wie Pair oder
Map.Entry (in Bibliotheken oder via Apache Commons, Vavr, etc.), aber f√ºr
deinen Fall w√§re ein eigener Container sinnvoller, weil du genau wei√üt, welche
Felder du brauchst.

### Beispiel: Eigene Container-Klasse

```java
public class DocumentContainer {
    private Document document;
    private List<DocumentAttribute> attributes;

    public DocumentContainer(Document document, List<DocumentAttribute> attributes) {
        this.document = document;
        this.attributes = attributes;
    }

    public Document getDocument() {
        return document;
    }

    public List<DocumentAttribute> getAttributes() {
        return attributes;
    }

    public void setDocument(Document document) {
        this.document = document;
    }

    public void setAttributes(List<DocumentAttribute> attributes) {
        this.attributes = attributes;
    }
}
```

Du kannst diesen Container dann ganz normal verwenden:

```java
Document d = new Document();
List<DocumentAttribute> daList = new ArrayList<>();
DocumentContainer container = new DocumentContainer(d, daList);
```

### Alternative: Generischer Container (falls gew√ºnscht)

Falls du etwas **generischer** machen willst ‚Äì z.‚ÄØB. um es auch mit anderen
Typen verwenden zu k√∂nnen ‚Äì kannst du eine generische Klasse schreiben:

```java
public class Container<D, A> {
    private D document;
    private List<A> attributes;

    public Container(D document, List<A> attributes) {
        this.document = document;
        this.attributes = attributes;
    }

    public D getDocument() {
        return document;
    }

    public List<A> getAttributes() {
        return attributes;
    }

    public void setDocument(D document) {
        this.document = document;
    }

    public void setAttributes(List<A> attributes) {
        this.attributes = attributes;
    }
}
```

Verwendung:

```java
Container<Document, DocumentAttribute> container = new Container<>(d, daList);
```

### Fazit

Es gibt keine eingebaute Klasse wie `Container<Document>`, die direkt genau das
tut, was du brauchst ‚Äì aber du kannst entweder eine einfache spezifische Klasse
oder eine generische L√∂sung verwenden, je nachdem, wie flexibel du sein willst.

M√∂chtest du, dass der Container auch zus√§tzliche Funktionalit√§t bietet, z.‚ÄØB.
das Hinzuf√ºgen oder Entfernen von Attributen?

## Frage

Wenn ich eien abstrakte Klasse 
```java
public class Builder<T, B extends Builder<T, B>> {
    protected final T instance;

    public Builder(Supplier<T> supplier) {
        instance = supplier.get();
    }

    public <U> B with(BiConsumer<T, U> setter, U value) {
        setter.accept(instance, value);
        return self();
    }

    protected B self() {
        return (B) this;
    }

    public T build() {
        return instance;
    }
}
```

habe, wie sehe ein `ContainerBuilder` aus? Dabei moechte ich die Klasse
`Container<D, A>` benutzen. Danke dir.

## Antwort

Sehr gerne! Du hast bereits ein sehr **elegantes Builder-Pattern mit
Self-Referential Generics** (`B extends Builder<T, B>`) erstellt ‚Äì klasse
gemacht.

Jetzt m√∂chtest du einen konkreten `ContainerBuilder` erstellen, der
`Container<D, A>` (deine generische Container-Klasse mit `D` f√ºr das Dokument
und `A` f√ºr das Attribut) baut. Der Builder soll z.‚ÄØB. erm√∂glichen, ein
Dokument zu setzen und Attribute hinzuzuf√ºgen.

### Ziel

Ein Aufruf soll z.‚ÄØB. so aussehen:

```java
Container<Document, DocumentAttribute> container = new ContainerBuilder<Document, DocumentAttribute>()
    .withDocument(document)
    .addAttribute(attr1)
    .addAttribute(attr2)
    .build();
```

### 1. Die Container<D, A>-Klasse (wie oben):

Falls noch nicht vorhanden, hier nochmal als Grundlage:

```java
public class Container<D, A> {
    private D document;
    private List<A> attributes;

    public Container() {
        this.attributes = new ArrayList<>();
    }

    public D getDocument() {
        return document;
    }

    public void setDocument(D document) {
        this.document = document;
    }

    public List<A> getAttributes() {
        return attributes;
    }

    public void setAttributes(List<A> attributes) {
        this.attributes = attributes;
    }

    public void addAttribute(A attribute) {
        this.attributes.add(attribute);
    }
}
```

### 2. Der ContainerBuilder<D, A>:

```java
public class ContainerBuilder<D, A> extends Builder<Container<D, A>, ContainerBuilder<D, A>> {

    public ContainerBuilder() {
        super(Container::new);
    }

    public ContainerBuilder<D, A> withDocument(D document) {
        return with(Container::setDocument, document);
    }

    public ContainerBuilder<D, A> addAttribute(A attribute) {
        instance.addAttribute(attribute);
        return this;
    }

    public ContainerBuilder<D, A> withAttributes(List<A> attributes) {
        return with(Container::setAttributes, attributes);
    }

    @Override
    protected ContainerBuilder<D, A> self() {
        return this;
    }
}
```

### 3. Verwendung:

```java
Document doc = new Document();
DocumentAttribute attr1 = new DocumentAttribute();
DocumentAttribute attr2 = new DocumentAttribute();

Container<Document, DocumentAttribute> container = new ContainerBuilder<Document, DocumentAttribute>()
    .withDocument(doc)
    .addAttribute(attr1)
    .addAttribute(attr2)
    .build();
```

### Fazit

Mit dieser L√∂sung nutzt du dein generisches, fluent Builder-Pattern perfekt. Du
kannst den `ContainerBuilder` noch weiter anpassen ‚Äì etwa Validierung in
`build()` einf√ºgen oder Defaults setzen.

Wenn du m√∂chtest, kann ich dir auch eine Version mit einer
`static`-Factory-Methode `builder()` oder mit Lombok zeigen. Sag einfach
Bescheid!

## Frage

Die Validator Klasse koennten wir schon wie folgt erweitern:

```java
import java.util.Optional;
import java.util.function.Predicate;

@FunctionalInterface
public interface Validator<T> {

    Optional<String> validate(T t);

    static <T> Validator<T> of(Predicate<T> predicate, String errorMessage) {
        return t -> predicate.test(t) ? Optional.empty() : Optional.of(errorMessage);
    }

    default Validator<T> and(Validator<T> other) {
        return t -> {
            Optional<String> error = this.validate(t);
            return error.isPresent() ? error : other.validate(t);
        };
    }

    default Validator<T> or(Validator<T> other) {
        return t -> {
            Optional<String> error = this.validate(t);
            return error.isEmpty() ? Optional.empty() : other.validate(t);
        };
    }

    default Validator<T> not(String errorMessage) {
        return t -> {
            Optional<String> error = this.validate(t);
            return error.isEmpty() ? Optional.of(errorMessage) : Optional.empty();
        };
    }
}
```

Dann schwebt mir sowas in den Gedanken, wie das folgende Beispiel, nur statt
`Person` sollte der `Container<D, A>` genommen werden:

```java
ValidatingBuilder<Person> builder = new ValidatingBuilder<>(Person::new)
    .with(Person::setName, "Alice")
    .with(Person::setAge, 25)
    .withValidator(Validator.of(p -> p.getName() != null && !p.getName().isEmpty(), "Name darf nicht leer sein"))
    .withValidator(Validator.of(p -> p.getAge() != null && p.getAge() >= 18, "Alter muss mindestens 18 sein"));

ValidationResult<Person> result = builder.buildResult();

if (result.isValid()) {
    Person person = result.getResult();
    // Person verwenden
} else {
    result.getErrors().forEach(System.out::println);
}
```
Das geht doch sicherlich auch, oder?

## Antwort

Ja, absolut ‚Äì das geht wunderbar, und du bist hier auf dem besten Weg zu einem
**sehr sauberen, funktionalen und wiederverwendbaren Validierungs-Builder-
Pattern** in Java. Deine `Validator<T>`-Schnittstelle mit kombinierten `and`,
`or`, `not`-Logiken ist hervorragend ‚Äì das ist modern, funktional und sehr
elegant!

### Was du erreichen willst

Du m√∂chtest:
- Einen generischen Builder mit Validierungslogik (z.‚ÄØB. ValidatingBuilder<T>),
- Die M√∂glichkeit, mehrere Regeln via Validator<T> zu verkn√ºpfen,
- Am Ende eine saubere ValidationResult<T>-Antwort mit:
  - dem gebauten Objekt (T) oder
  - einer Liste von Fehlermeldungen.

Und das f√ºr jede Klasse wie z.‚ÄØB. Container<D, A> oder Person.

### 1. `ValidationResult<T>` (Hilfsklasse f√ºr das Ergebnis)

```java
public class ValidationResult<T> {
    private final T result;
    private final List<String> errors;

    public ValidationResult(T result, List<String> errors) {
        this.result = result;
        this.errors = errors;
    }

    public boolean isValid() {
        return errors == null || errors.isEmpty();
    }

    public T getResult() {
        return result;
    }

    public List<String> getErrors() {
        return errors;
    }
}
```

### 2. ValidatingBuilder<T> (generischer Builder mit Validierung)

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Supplier;

public class ValidatingBuilder<T> {
    protected final T instance;
    protected final List<Validator<T>> validators = new ArrayList<>();

    public ValidatingBuilder(Supplier<T> supplier) {
        this.instance = supplier.get();
    }

    public <U> ValidatingBuilder<T> with(BiConsumer<T, U> setter, U value) {
        setter.accept(instance, value);
        return this;
    }

    public ValidatingBuilder<T> withValidator(Validator<T> validator) {
        validators.add(validator);
        return this;
    }

    public ValidationResult<T> buildResult() {
        List<String> errors = new ArrayList<>();

        for (Validator<T> validator : validators) {
            Optional<String> result = validator.validate(instance);
            result.ifPresent(errors::add);
        }

        return new ValidationResult<>(instance, errors);
    }
}
```

### Beispielverwendung mit `Container<Document, DocumentAttribute>`

```java
Document doc = new Document();
DocumentAttribute attr = new DocumentAttribute();

ValidatingBuilder<Container<Document, DocumentAttribute>> builder =
    new ValidatingBuilder<>(Container::new)
        .with(Container::setDocument, doc)
        .with(Container::setAttributes, List.of(attr))
        .withValidator(Validator.of(c -> c.getDocument() != null, "Document darf nicht null sein"))
        .withValidator(Validator.of(c -> c.getAttributes() != null, "Attribute-Liste darf nicht null sein"))
        .withValidator(Validator.of(c -> !c.getAttributes().isEmpty(), "Es muss mindestens ein Attribut geben"));

ValidationResult<Container<Document, DocumentAttribute>> result = builder.buildResult();

if (result.isValid()) {
    Container<Document, DocumentAttribute> container = result.getResult();
    // Weiterverarbeiten...
} else {
    result.getErrors().forEach(System.out::println);
}
```

### Bonus: Kombinierte Regeln

Dein `Validator<T>`-Interface mit `and()/or()` erlaubt sehr sch√∂ne
Kombinationslogik:

```java
Validator<Container<Document, DocumentAttribute>> documentPresent =
    Validator.of(c -> c.getDocument() != null, "Dokument fehlt");

Validator<Container<Document, DocumentAttribute>> attributesValid =
    Validator.of(c -> c.getAttributes() != null && !c.getAttributes().isEmpty(), "Keine Attribute gesetzt");

builder.withValidator(documentPresent.and(attributesValid));
```

## Frage

Oder waere es besser dem ContainerBuilder eine Liste von Validatoren zu
uebergeben, die bei der der Methode build() auf dem Inhalt des Containers
ausgefuehrt werden?

## Antwort


Sehr gute und wichtige Frage! Beide Ans√§tze ‚Äì der **generische**
`ValidatingBuilder<T>` und der **spezialisierte ContainerBuilder mit
integrierten Validatoren** ‚Äì haben ihre St√§rken. Welcher besser passt, h√§ngt
davon ab, wie viel **Wiederverwendbarkeiti**, **Flexibilit√§t** und
**Dom√§nenspezifik** du brauchst.

### Kurzer Vergleich


| Kriterium                                  | `ValidatingBuilder<T>` (generisch)            | `ContainerBuilder` mit Validator-Liste      |
| ------------------------------------------ | --------------------------------------------- | ------------------------------------------- |
| ‚úÖ **Wiederverwendbarkeit**                | Hoch ‚Äì f√ºr beliebige Typen verwendbar         | Eher niedrig ‚Äì nur f√ºr `Container<D,A>`     |
| ‚öôÔ∏è **Flexibilit√§t bei Regeln**             | Sehr flexibel (beliebige Validatoren)         | Mittel ‚Äì Fokus auf Container-bezogene Logik |
| üß† **Lesbarkeit und Klarheit**             | Klar, wenn gut strukturiert                   | Klar, wenn nur Container validiert werden   |
| üß± **Dom√§nenspezifische Kontrolle**        | Muss durch externe Validatoren erg√§nzt werden | Direkt eingebaut in ContainerBuilder        |
| üîÑ **Verh√§ltnis von Bauen und Validieren** | Entkoppelt (sehr gut testbar)                 | Gekoppelt (einfacher in manchen F√§llen)     |


### Variante 1: ContainerBuilder mit Validatoren


Vorteil:
- Du kapselst alles in einem spezialisierten Builder: Konstruktion + Validierung.
- Du kannst container-spezifische Regeln besser einschlie√üen.
- Weniger generische "Plumbing" n√∂tig, wenn du nur Container bauen willst.

Beispiel:

```java
public class ContainerBuilder<D, A> extends Builder<Container<D, A>, ContainerBuilder<D, A>> {

    private final List<Validator<Container<D, A>>> validators = new ArrayList<>();

    public ContainerBuilder() {
        super(Container::new);
    }

    public ContainerBuilder<D, A> withDocument(D document) {
        return with(Container::setDocument, document);
    }

    public ContainerBuilder<D, A> addAttribute(A attribute) {
        instance.addAttribute(attribute);
        return this;
    }

    public ContainerBuilder<D, A> withAttributes(List<A> attributes) {
        return with(Container::setAttributes, attributes);
    }

    public ContainerBuilder<D, A> withValidator(Validator<Container<D, A>> validator) {
        validators.add(validator);
        return this;
    }

    @Override
    protected ContainerBuilder<D, A> self() {
        return this;
    }

    public ValidationResult<Container<D, A>> buildResult() {
        List<String> errors = new ArrayList<>();
        for (Validator<Container<D, A>> validator : validators) {
            validator.validate(instance).ifPresent(errors::add);
        }
        return new ValidationResult<>(instance, errors);
    }

    @Override
    public Container<D, A> build() {
        ValidationResult<Container<D, A>> result = buildResult();
        if (!result.isValid()) {
            throw new IllegalStateException("Validation failed: " + String.join(", ", result.getErrors()));
        }
        return result.getResult();
    }
}
```

### Wann ist das besser?

- Wenn du nur `Container<D, A>` brauchst und nicht f√ºr jede Klasse einen neuen `ValidatingBuilder<T>` erzeugen willst.
- Wenn du **feste, dom√§nenspezifische Regeln** innerhalb des Builders willst (z.‚ÄØB. Pflichtfelder).
- Wenn du **Builder + Validator zusammengeh√∂rig** betrachten m√∂chtest (was in der Praxis oft sinnvoll ist).

### Empfehlung

Wenn du eine dom√§nenspezifische Anwendung hast:
‚û§ Bevorzuge den spezialisierten `ContainerBuilder` mit Validatorliste.

Wenn du eine Library oder ein wiederverwendbares Tool bauen willst:
‚û§ Verwende den generischen `ValidatingBuilder<T>` und halte die Validatoren
  getrennt, eventuell sogar in wiederverwendbaren ValidatorSets.

### Hybrid: beides kombinieren


Du kannst auch folgendes machen:
- Nutze `ValidatingBuilder<T>` als Basis.
- Spezialisiere `ContainerBuilder` darauf:

```java
public class ContainerBuilder<D, A> extends ValidatingBuilder<Container<D, A>> {
    public ContainerBuilder() {
        super(Container::new);
    }

    public ContainerBuilder<D, A> withDocument(D document) {
        return (ContainerBuilder<D, A>) with(Container::setDocument, document);
    }

    public ContainerBuilder<D, A> addAttribute(A attribute) {
        instance.addAttribute(attribute);
        return this;
    }

    public ContainerBuilder<D, A> withAttributes(List<A> attributes) {
        return (ContainerBuilder<D, A>) with(Container::setAttributes, attributes);
    }
}
```

Dann hast du beides: **Generik + Spezialisierung**.

## Frage

Wie sehe ein Validator aus, der alle Attribute des Containers auf ein
Vorhandensein eines Attributs in der Klasse (z.B DocumentAttribute.pvaID mit
pvaID als Integer)?

## Antwort

Super Frage! Du m√∂chtest einen Validator f√ºr `Container<D, A>`, der
sicherstellt, dass alle Attribute eine bestimmte Eigenschaft besitzen ‚Äì z.‚ÄØB.
dass DocumentAttribute.pvaID != null ist.

### Ziel:

Ein Validator<Container<D, A>>, der pr√ºft:

> F√ºr **alle** `A` **in* `getAttributes()` gilt: `pvaID != null`

Das Ganze nat√ºrlich generisch, aber typensicher und wiederverwendbar.


### Voraussetzung: Zugriff auf pvaID

Wir m√ºssen wissen, wie man bei einem `A`-Objekt (z.‚ÄØB. DocumentAttribute) den
Wert von `pvaID` bekommt. Das geht z.‚ÄØB. mit einem **Function<A, Integer>**,
also einem "Getter".

### Der Validator

```java
import java.util.function.Function;

public class AttributeFieldNotNullValidator<D, A> {

    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldNotNull(
            Function<A, U> fieldGetter,
            String fieldName
    ) {
        return container -> {
            if (container.getAttributes() == null) {
                return Optional.of("Attributliste ist null");
            }

            boolean allPresent = container.getAttributes().stream()
                    .allMatch(attr -> fieldGetter.apply(attr) != null);

            return allPresent
                    ? Optional.empty()
                    : Optional.of("Nicht alle Attribute haben ein gesetztes Feld: " + fieldName);
        };
    }
}
```

### Anwendung (Beispiel mit `DocumentAttribute`)


Angenommen:

```java
public class DocumentAttribute {
    private Integer pvaID;
    public Integer getPvaID() { return pvaID; }
    public void setPvaID(Integer pvaID) { this.pvaID = pvaID; }
}
```

Dann kannst du den Validator so verwenden:

```java
Validator<Container<Document, DocumentAttribute>> pvaIDValidator =
    AttributeFieldNotNullValidator
        .allAttributesFieldNotNull(DocumentAttribute::getPvaID, "pvaID");

builder.withValidator(pvaIDValidator);
```

### Optional: Mehrere Feld-Validatoren kombinieren


Wenn du willst, kannst du mehrere solcher Feldpr√ºfungen kombinieren:

```java
builder
    .withValidator(pvaIDValidator)
    .withValidator(
        AttributeFieldNotNullValidator.allAttributesFieldNotNull(
            DocumentAttribute::getSomeOtherField, "someOtherField"
        )
    );
```

### Fazit

Mit der oben definierten Utility-Methode allAttributesFieldNotNull(...) kannst du:
- Typensicher definieren, welches Feld gepr√ºft werden soll,
- Reusable Validatoren f√ºr jedes Attributfeld schreiben,
- Klar benennen, welches Feld fehlt, wenn die Validierung fehlschl√§gt.

Wenn du magst, kann ich dir noch eine Version zeigen, die auch z.‚ÄØB. pr√ºft, ob
ein Feld innerhalb eines bestimmten Wertebereichs liegt. Sag einfach Bescheid!

## Frage

Dieser AttributeFieldNotNullValidator ist in deinem Beispiel keine Unterklasse
von Validator<T>. Warum?

## Antwort

Sehr guter Punkt ‚Äì und du hast v√∂llig recht, das verdient eine klare Erkl√§rung.

### Warum ist AttributeFieldNotNullValidator keine Unterklasse von Validator<T>?

Weil:
Sie ist keine Implementierung, sondern nur ein Hilfs-Konstruktor f√ºr
`Validator<Container<D, A>>`.

### Was ist es dann?

Die Klasse (bzw. sie k√∂nnte auch einfach ein Utility-Class sein) liefert eine
Instanz von `Validator<Container<D, A>>`, aber sie selbst implementiert nicht das
Interface `Validator<T>`.

```java
public class AttributeFieldNotNullValidator<D, A> {

    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldNotNull(
            Function<A, U> fieldGetter,
            String fieldName
    ) {
        return container -> {
            // Validation logic ...
        };
    }
}
```

### Alternativen ‚Äì was w√§re m√∂glich?

1. Utility-Klasse (empfohlen)
So wie oben ‚Äì AttributeFieldNotNullValidator ist einfach nur ein Helper mit statischen Methoden.

üëâ Vorteil: Kein Overhead, keine unn√∂tige Vererbung, sehr lesbar.

2. Eigene Validator-Klasse (falls du Instanzvariablen brauchst)
Wenn du z.‚ÄØB. den fieldGetter und fieldName als Felder halten willst:

```java
public class AttributeFieldNotNullValidator<D, A, U> implements Validator<Container<D, A>> {
    private final Function<A, U> getter;
    private final String fieldName;

    public AttributeFieldNotNullValidator(Function<A, U> getter, String fieldName) {
        this.getter = getter;
        this.fieldName = fieldName;
    }

    @Override
    public Optional<String> validate(Container<D, A> container) {
        if (container.getAttributes() == null) {
            return Optional.of("Attributliste ist null");
        }

        boolean allPresent = container.getAttributes().stream()
                .allMatch(attr -> getter.apply(attr) != null);

        return allPresent
                ? Optional.empty()
                : Optional.of("Nicht alle Attribute haben ein gesetztes Feld: " + fieldName);
    }
}
```

Dann kannst du ihn auch so verwenden:

```java
builder.withValidator(
    new AttributeFieldNotNullValidator<>(DocumentAttribute::getPvaID, "pvaID")
);
```

### Empfehlung

| Situation                                   | L√∂sung                                                 |
| ------------------------------------------- | ------------------------------------------------------ |
| üîÅ Einmalige oder einfache Verwendung       | Nutze eine `static`-Factory-Methode (wie oben gezeigt) |
| üîß Komplexe Logik, erweiterbare Validatoren | Nutze eine eigene `Validator`-Implementierungsklasse   |

## Frage

Kann man die letzte Loesung auch in einen `Validator.of()` Aufruf verwandeln? 

## Antwort

Ja, absolut! Du kannst die letzte L√∂sung ‚Äì also die Pr√ºfung, ob bei allen
Attributen eines Containers ein bestimmtes Feld gesetzt ist ‚Äì auch vollst√§ndig
in einen Aufruf von Validator.of(...) packen, wenn du lieber inline arbeitest
oder auf eine Utility-Klasse verzichten m√∂chtest.

### Beispiel: `Validator.of(...)` f√ºr `DocumentAttribute.pvaID != null`

Angenommen:

```java
public class DocumentAttribute {
    private Integer pvaID;

    public Integer getPvaID() {
        return pvaID;
    }

    public void setPvaID(Integer pvaID) {
        this.pvaID = pvaID;
    }
}
```

Dann kannst du den `Validator<Container<D, A>>` direkt so bauen:

```java
Validator<Container<Document, DocumentAttribute>> pvaIDValidator =
    Validator.of(
        container -> container.getAttributes() != null &&
                     container.getAttributes().stream().allMatch(attr -> attr.getPvaID() != null),
        "Nicht alle Attribute haben ein gesetztes Feld: pvaID"
    );
```
### Fazit

Ja, du kannst und solltest solche einfachen Validierungen direkt mit Validator.of(...) definieren, wenn:
- sie kurz und verst√§ndlich sind,
- du keine zustandsbehaftete Klasse brauchst.
F√ºr komplexere oder wiederholte Validierungen lohnt sich ein Utility oder eine eigene Validator-Klasse.

Wenn du magst, kann ich dir ein kleines ValidatorUtils-Toolkit mit solchen Methoden zusammenstellen.

## Frage

na dann Zeige mit dieses ValidatorUtils. Danke dir. :) Ist eine tolle Idee!

## Antwort

Sehr gerne ‚Äì freut mich, dass dir die Idee gef√§llt! üéâ

Hier ist ein **generisches** `ValidatorUtils` **Toolkit**, das dir hilft,
typische Validierungen f√ºr Container-Objekte und deren Attribute zu kapseln und
wiederzuverwenden. Es ist **typsicher**, flexibel und Java-idiomatisch gehalten.

### ValidatorUtils ‚Äì die Klasse

```java
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public final class ValidatorUtils {

    private ValidatorUtils() {
        // Utility class ‚Äì no instantiation
    }

    /**
     * Pr√ºft, ob ein Feld in allen Attributen vorhanden ist (nicht null).
     */
    public static <D, A, U> Validator<Container<D, A>> allAttributesHaveField(
            Function<A, U> fieldGetter,
            String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream().allMatch(attr -> fieldGetter.apply(attr) != null),
            "Nicht alle Attribute haben ein gesetztes Feld: " + fieldName
        );
    }

    /**
     * Pr√ºft, ob mindestens ein Attribut das Feld erf√ºllt.
     */
    public static <D, A, U> Validator<Container<D, A>> anyAttributeHasFieldMatching(
            Function<A, U> fieldGetter,
            Predicate<U> predicate,
            String errorMessage
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .anyMatch(value -> value != null && predicate.test(value)),
            errorMessage
        );
    }

    /**
     * Pr√ºft, ob alle Attribute ein Feld innerhalb eines Wertebereichs haben.
     */
    public static <D, A, U extends Comparable<U>> Validator<Container<D, A>> allAttributesFieldInRange(
            Function<A, U> fieldGetter,
            U min,
            U max,
            String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(value -> value != null && value.compareTo(min) >= 0 && value.compareTo(max) <= 0),
            String.format("Feld '%s' muss zwischen %s und %s liegen", fieldName, min, max)
        );
    }

    /**
     * Pr√ºft, ob alle Attribute eine Liste von erlaubten Werten enthalten.
     */
    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldInAllowedValues(
            Function<A, U> fieldGetter,
            List<U> allowedValues,
            String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(allowedValues::contains),
            String.format("Feld '%s' enth√§lt ung√ºltige Werte. Erlaubt sind: %s", fieldName, allowedValues)
        );
    }

    /**
     * Pr√ºft, ob die Attributliste leer ist.
     */
    public static <D, A> Validator<Container<D, A>> attributesNotEmpty(String errorMessage) {
        return Validator.of(
            container -> container.getAttributes() != null && !container.getAttributes().isEmpty(),
            errorMessage
        );
    }

    /**
     * Kombiniert mehrere Validatoren in einen einzigen.
     */
    @SafeVarargs
    public static <T> Validator<T> combineAll(Validator<T>... validators) {
        return t -> {
            for (Validator<T> validator : validators) {
                Optional<String> result = validator.validate(t);
                if (result.isPresent()) return result;
            }
            return Optional.empty();
        };
    }

    /**
     * F√ºhrt alle Validatoren aus und sammelt alle Fehler (nicht nur den ersten).
     */
    @SafeVarargs
    public static <T> Validator<T> collectAllErrors(Validator<T>... validators) {
        return t -> {
            List<String> errors = 
                List.of(validators).stream()
                    .map(v -> v.validate(t))
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .collect(Collectors.toList());

            return errors.isEmpty()
                ? Optional.empty()
                : Optional.of(String.join("; ", errors));
        };
    }
}
```

### Beispielnutzung

```java
Validator<Container<Document, DocumentAttribute>> validator = ValidatorUtils.combineAll(
    ValidatorUtils.attributesNotEmpty("Die Attributliste darf nicht leer sein"),
    ValidatorUtils.allAttributesHaveField(DocumentAttribute::getPvaID, "pvaID"),
    ValidatorUtils.allAttributesFieldInRange(DocumentAttribute::getPvaID, 1000, 9999, "pvaID")
);
```

Oder mit deinem `ContainerBuilder`:

```java
ContainerBuilder<Document, DocumentAttribute> builder = new ContainerBuilder<>();

builder
    .withDocument(new Document())
    .addAttribute(new DocumentAttribute(1234)) // z.‚ÄØB. mit gesetztem pvaID
    .withValidator(validator);
```

### Erweiterungsideen

Du kannst ValidatorUtils ganz einfach erweitern um:
- Pflichtfelder auf dem Container selbst (nicht nur Attributebene)
- Einzigartigkeit (z.‚ÄØB. kein Attribut hat denselben Schl√ºssel)
- Kombinationsregeln (z.‚ÄØB. ‚Äûwenn A gesetzt ist, muss B gesetzt sein‚Äú)

## Frage

Wie sehe das aus: Kombinationsregeln (z.‚ÄØB. ‚Äûwenn A gesetzt ist, muss B gesetzt sein‚Äú)?

## Antwort


Sehr gute Frage ‚Äì **Kombinationsregel**n (‚ÄûWenn A, dann B‚Äú) sind in der
Validierung von Objekten extrem wichtig, und elegant l√∂sbar, wenn man mit dem
`Validator<T>`-Prinzip arbeitet.

### Ziel:

Wenn Feld A **gesetzt** ist, dann **muss auch Feld B gesetzt** sein (z.‚ÄØB. nicht null).

Oder umgekehrt:

Wenn A **nicht gesetzt** ist, darf B **auch nicht gesetzt sein**. (Optional: symmetrisch oder einseitig pr√ºfen.)

### Beispiel (konkret mit DocumentAttribute):

```java
public class DocumentAttribute {
    private String key;
    private String value;

    // z.‚ÄØB.
    // if key != null => value != null
}
```

### Kombinationsregel-Validator (typsicher und wiederverwendbar)

```java
public class ValidatorUtils {

    // ...

    /**
     * Wenn Feld A gesetzt ist, muss Feld B auch gesetzt sein.
     */
    public static <T, U, V> Validator<T> ifFieldSetThenOtherFieldMustBeSet(
            Function<T, U> fieldAGetter,
            Function<T, V> fieldBGetter,
            String fieldAName,
            String fieldBName
    ) {
        return Validator.of(
            t -> {
                U fieldA = fieldAGetter.apply(t);
                V fieldB = fieldBGetter.apply(t);

                // Wenn A gesetzt ist, muss B auch gesetzt sein
                return fieldA == null || fieldB != null;
            },
            String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein", fieldAName, fieldBName)
        );
    }

}
```

### Beispielnutzung mit einem einzelnen DocumentAttribute:

```java

    ValidatorUtils.ifFieldSetThenOtherFieldMustBeSet(
        DocumentAttribute::getKey,
        DocumentAttribute::getValue,
        "key",
        "value"
    );
```

### Erweiterung f√ºr eine `Container<D, A>`-Struktur:

```java
public static <D, A, U, V> Validator<Container<D, A>> attributeFieldDependency(
        Function<A, U> fieldAGetter,
        Function<A, V> fieldBGetter,
        String fieldAName,
        String fieldBName
) {
    return Validator.of(
        container -> container.getAttributes() != null &&
                     container.getAttributes().stream()
                             .allMatch(attr -> {
                                 U fieldA = fieldAGetter.apply(attr);
                                 V fieldB = fieldBGetter.apply(attr);
                                 return fieldA == null || fieldB != null;
                             }),
        String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein (bei mindestens einem Attribut verletzt)", fieldAName, fieldBName)
    );
}
```

Dann so verwenden:

```java
Validator<Container<Document, DocumentAttribute>> validator =
    ValidatorUtils.attributeFieldDependency(
        DocumentAttribute::getKey,
        DocumentAttribute::getValue,
        "key",
        "value"
    );
```

### Weitere Varianten m√∂glich:

| Regeltyp                                                       | Beispiel                           |
| -------------------------------------------------------------- | ---------------------------------- |
| Wenn A gesetzt ist, darf B **nicht** gesetzt sein              | Konfliktpr√ºfung                    |
| Wenn A einen bestimmten **Wert** hat, dann muss B gesetzt sein | Konfiguration abh√§ngig von Auswahl |
| Wenn A == X, dann B == Y                                       | Kopplung von Feldern               |

## Frage

Wenn du magst, kann ich dir aus diesen Methoden direkt eine kompakte
ValidatorUtils.java Datei zum Copy-Paste liefern ‚Äì einfach Bescheid sagen.

## Antwort

Ja pack mir diese Methoden in eine ValidatorUtils Klasse.

Sehr gerne! Hier ist die vollst√§ndige und saubere ValidatorUtils-Klasse mit
allen besprochenen Methoden f√ºr kombinatorische Validierungen und
Standardpr√ºfungen von Feldern in Containern und Objekten.

### ValidatorUtils.java

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

public final class ValidatorUtils {

    private ValidatorUtils() {
        // Utility class ‚Äî no instantiation
    }

    // === Standard Container-Validatoren ===

    public static <D, A> Validator<Container<D, A>> attributesNotEmpty(String errorMessage) {
        return Validator.of(
            container -> container.getAttributes() != null && !container.getAttributes().isEmpty(),
            errorMessage
        );
    }

    public static <D, A, U> Validator<Container<D, A>> allAttributesHaveField(
        Function<A, U> fieldGetter,
        String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream().allMatch(attr -> fieldGetter.apply(attr) != null),
            "Nicht alle Attribute haben ein gesetztes Feld: " + fieldName
        );
    }

    public static <D, A, U, V> Validator<Container<D, A>> attributeFieldDependency(
        Function<A, U> fieldAGetter,
        Function<A, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .allMatch(attr -> {
                                 U a = fieldAGetter.apply(attr);
                                 V b = fieldBGetter.apply(attr);
                                 return a == null || b != null;
                             }),
            String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein (in einem Attribut verletzt)", fieldAName, fieldBName)
        );
    }

    public static <D, A, U extends Comparable<U>> Validator<Container<D, A>> allAttributesFieldInRange(
        Function<A, U> fieldGetter,
        U min,
        U max,
        String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(value -> value != null && value.compareTo(min) >= 0 && value.compareTo(max) <= 0),
            String.format("Feld '%s' muss zwischen %s und %s liegen", fieldName, min, max)
        );
    }

    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldInAllowedValues(
        Function<A, U> fieldGetter,
        List<U> allowedValues,
        String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(allowedValues::contains),
            String.format("Feld '%s' enth√§lt ung√ºltige Werte. Erlaubt sind: %s", fieldName, allowedValues)
        );
    }

    public static <D, A> Validator<Container<D, A>> attributesMustSatisfy(
        Predicate<A> attributePredicate,
        String errorMessage
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream().allMatch(attributePredicate),
            errorMessage
        );
    }

    // === Kombinationsregeln (Feldabh√§ngigkeiten) ===

    public static <T, U, V> Validator<T> ifFieldSetThenOtherFieldMustBeSet(
        Function<T, U> fieldAGetter,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return a == null || b != null;
            },
            String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein", fieldAName, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldSetThenOtherFieldMustBeNull(
        Function<T, U> fieldAGetter,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return a == null || b == null;
            },
            String.format("Wenn '%s' gesetzt ist, darf '%s' nicht gesetzt sein", fieldAName, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldUnsetThenOtherFieldMustAlsoBeUnset(
        Function<T, U> fieldAGetter,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return a != null || b == null;
            },
            String.format("Wenn '%s' nicht gesetzt ist, darf '%s' auch nicht gesetzt sein", fieldAName, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldEqualsThenOtherFieldRequired(
        Function<T, U> fieldAGetter,
        U expectedValue,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String expectedValueLabel,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return !Objects.equals(a, expectedValue) || b != null;
            },
            String.format("Wenn '%s' == %s, muss '%s' gesetzt sein", fieldAName, expectedValueLabel, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldEqualsThenOtherMustEqual(
        Function<T, U> fieldAGetter,
        U expectedA,
        Function<T, V> fieldBGetter,
        V expectedB,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return !Objects.equals(a, expectedA) || Objects.equals(b, expectedB);
            },
            String.format("Wenn '%s' == %s, muss '%s' == %s sein", fieldAName, expectedA, fieldBName, expectedB)
        );
    }

    // === Zusammensetzung ===

    @SafeVarargs
    public static <T> Validator<T> combineAll(Validator<T>... validators) {
        return t -> {
            for (Validator<T> v : validators) {
                Optional<String> error = v.validate(t);
                if (error.isPresent()) return error;
            }
            return Optional.empty();
        };
    }

    @SafeVarargs
    public static <T> Validator<T> collectAllErrors(Validator<T>... validators) {
        return t -> {
            List<String> errors = Arrays.stream(validators)
                .map(v -> v.validate(t))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());

            return errors.isEmpty()
                ? Optional.empty()
                : Optional.of(String.join("; ", errors));
        };
    }
}
```

### Jetzt kannst du z.‚ÄØB. schreiben:

```java
Validator<Container<Document, DocumentAttribute>> validator = ValidatorUtils.combineAll(
    ValidatorUtils.attributesNotEmpty("Mindestens ein Attribut muss vorhanden sein"),
    ValidatorUtils.allAttributesHaveField(DocumentAttribute::getPvaID, "pvaID"),
    ValidatorUtils.attributeFieldDependency(DocumentAttribute::getKey, DocumentAttribute::getValue, "key", "value"),
    ValidatorUtils.ifFieldEqualsThenOtherMustEqual(
        DocumentAttribute::getKey, "status",
        DocumentAttribute::getValue, "ACTIVE",
        "key", "value"
    )
);
```
