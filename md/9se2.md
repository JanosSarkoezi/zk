# Typisierter Container in Java

## Frage

> Angenommen ich habe zwei Objete, `Document` (d) und `DocumentAttribute` (da). Ich
> moechte einen `Container` aufbauen, in der das d und eine Liste von da sind.
> Gibt es in Java eine typisierbare Container-Klasse? Meine sowas wie
> `Container<Document>`?

## Antwort

Ja, in Java kannst du dir einen typisierten Container ganz einfach selbst
erstellen – das ist ein gängiges Muster, besonders wenn du eine bestimmte
Kombination von Objekten bündeln möchtest (z. B. ein Document und eine Liste
von DocumentAttribute). Java bietet zwar generische Klassen wie Pair oder
Map.Entry (in Bibliotheken oder via Apache Commons, Vavr, etc.), aber für
deinen Fall wäre ein eigener Container sinnvoller, weil du genau weißt, welche
Felder du brauchst.

### Beispiel: Eigene Container-Klasse

```java
public class DocumentContainer {
    private Document document;
    private List<DocumentAttribute> attributes;

    public DocumentContainer(Document document, List<DocumentAttribute> attributes) {
        this.document = document;
        this.attributes = attributes;
    }

    public Document getDocument() {
        return document;
    }

    public List<DocumentAttribute> getAttributes() {
        return attributes;
    }

    public void setDocument(Document document) {
        this.document = document;
    }

    public void setAttributes(List<DocumentAttribute> attributes) {
        this.attributes = attributes;
    }
}
```

Du kannst diesen Container dann ganz normal verwenden:

```java
Document d = new Document();
List<DocumentAttribute> daList = new ArrayList<>();
DocumentContainer container = new DocumentContainer(d, daList);
```

### Alternative: Generischer Container (falls gewünscht)

Falls du etwas **generischer** machen willst – z. B. um es auch mit anderen
Typen verwenden zu können – kannst du eine generische Klasse schreiben:

```java
public class Container<D, A> {
    private D document;
    private List<A> attributes;

    public Container(D document, List<A> attributes) {
        this.document = document;
        this.attributes = attributes;
    }

    public D getDocument() {
        return document;
    }

    public List<A> getAttributes() {
        return attributes;
    }

    public void setDocument(D document) {
        this.document = document;
    }

    public void setAttributes(List<A> attributes) {
        this.attributes = attributes;
    }
}
```

Verwendung:

```java
Container<Document, DocumentAttribute> container = new Container<>(d, daList);
```

### Fazit

Es gibt keine eingebaute Klasse wie `Container<Document>`, die direkt genau das
tut, was du brauchst – aber du kannst entweder eine einfache spezifische Klasse
oder eine generische Lösung verwenden, je nachdem, wie flexibel du sein willst.

Möchtest du, dass der Container auch zusätzliche Funktionalität bietet, z. B.
das Hinzufügen oder Entfernen von Attributen?

## Frage

Wenn ich eien abstrakte Klasse 
```java
public class Builder<T, B extends Builder<T, B>> {
    protected final T instance;

    public Builder(Supplier<T> supplier) {
        instance = supplier.get();
    }

    public <U> B with(BiConsumer<T, U> setter, U value) {
        setter.accept(instance, value);
        return self();
    }

    protected B self() {
        return (B) this;
    }

    public T build() {
        return instance;
    }
}
```

habe, wie sehe ein `ContainerBuilder` aus? Dabei moechte ich die Klasse
`Container<D, A>` benutzen. Danke dir.

## Antwort

Sehr gerne! Du hast bereits ein sehr **elegantes Builder-Pattern mit
Self-Referential Generics** (`B extends Builder<T, B>`) erstellt – klasse
gemacht.

Jetzt möchtest du einen konkreten `ContainerBuilder` erstellen, der
`Container<D, A>` (deine generische Container-Klasse mit `D` für das Dokument
und `A` für das Attribut) baut. Der Builder soll z. B. ermöglichen, ein
Dokument zu setzen und Attribute hinzuzufügen.

### Ziel

Ein Aufruf soll z. B. so aussehen:

```java
Container<Document, DocumentAttribute> container = new ContainerBuilder<Document, DocumentAttribute>()
    .withDocument(document)
    .addAttribute(attr1)
    .addAttribute(attr2)
    .build();
```

### 1. Die Container<D, A>-Klasse (wie oben):

Falls noch nicht vorhanden, hier nochmal als Grundlage:

```java
public class Container<D, A> {
    private D document;
    private List<A> attributes;

    public Container() {
        this.attributes = new ArrayList<>();
    }

    public D getDocument() {
        return document;
    }

    public void setDocument(D document) {
        this.document = document;
    }

    public List<A> getAttributes() {
        return attributes;
    }

    public void setAttributes(List<A> attributes) {
        this.attributes = attributes;
    }

    public void addAttribute(A attribute) {
        this.attributes.add(attribute);
    }
}
```

### 2. Der ContainerBuilder<D, A>:

```java
public class ContainerBuilder<D, A> extends Builder<Container<D, A>, ContainerBuilder<D, A>> {

    public ContainerBuilder() {
        super(Container::new);
    }

    public ContainerBuilder<D, A> withDocument(D document) {
        return with(Container::setDocument, document);
    }

    public ContainerBuilder<D, A> addAttribute(A attribute) {
        instance.addAttribute(attribute);
        return this;
    }

    public ContainerBuilder<D, A> withAttributes(List<A> attributes) {
        return with(Container::setAttributes, attributes);
    }

    @Override
    protected ContainerBuilder<D, A> self() {
        return this;
    }
}
```

### 3. Verwendung:

```java
Document doc = new Document();
DocumentAttribute attr1 = new DocumentAttribute();
DocumentAttribute attr2 = new DocumentAttribute();

Container<Document, DocumentAttribute> container = new ContainerBuilder<Document, DocumentAttribute>()
    .withDocument(doc)
    .addAttribute(attr1)
    .addAttribute(attr2)
    .build();
```

### Fazit

Mit dieser Lösung nutzt du dein generisches, fluent Builder-Pattern perfekt. Du
kannst den `ContainerBuilder` noch weiter anpassen – etwa Validierung in
`build()` einfügen oder Defaults setzen.

Wenn du möchtest, kann ich dir auch eine Version mit einer
`static`-Factory-Methode `builder()` oder mit Lombok zeigen. Sag einfach
Bescheid!

## Frage

Die Validator Klasse koennten wir schon wie folgt erweitern:

```java
import java.util.Optional;
import java.util.function.Predicate;

@FunctionalInterface
public interface Validator<T> {

    Optional<String> validate(T t);

    static <T> Validator<T> of(Predicate<T> predicate, String errorMessage) {
        return t -> predicate.test(t) ? Optional.empty() : Optional.of(errorMessage);
    }

    default Validator<T> and(Validator<T> other) {
        return t -> {
            Optional<String> error = this.validate(t);
            return error.isPresent() ? error : other.validate(t);
        };
    }

    default Validator<T> or(Validator<T> other) {
        return t -> {
            Optional<String> error = this.validate(t);
            return error.isEmpty() ? Optional.empty() : other.validate(t);
        };
    }

    default Validator<T> not(String errorMessage) {
        return t -> {
            Optional<String> error = this.validate(t);
            return error.isEmpty() ? Optional.of(errorMessage) : Optional.empty();
        };
    }
}
```

Dann schwebt mir sowas in den Gedanken, wie das folgende Beispiel, nur statt
`Person` sollte der `Container<D, A>` genommen werden:

```java
ValidatingBuilder<Person> builder = new ValidatingBuilder<>(Person::new)
    .with(Person::setName, "Alice")
    .with(Person::setAge, 25)
    .withValidator(Validator.of(p -> p.getName() != null && !p.getName().isEmpty(), "Name darf nicht leer sein"))
    .withValidator(Validator.of(p -> p.getAge() != null && p.getAge() >= 18, "Alter muss mindestens 18 sein"));

ValidationResult<Person> result = builder.buildResult();

if (result.isValid()) {
    Person person = result.getResult();
    // Person verwenden
} else {
    result.getErrors().forEach(System.out::println);
}
```
Das geht doch sicherlich auch, oder?

## Antwort

Ja, absolut – das geht wunderbar, und du bist hier auf dem besten Weg zu einem
**sehr sauberen, funktionalen und wiederverwendbaren Validierungs-Builder-
Pattern** in Java. Deine `Validator<T>`-Schnittstelle mit kombinierten `and`,
`or`, `not`-Logiken ist hervorragend – das ist modern, funktional und sehr
elegant!

### Was du erreichen willst

Du möchtest:
- Einen generischen Builder mit Validierungslogik (z. B. ValidatingBuilder<T>),
- Die Möglichkeit, mehrere Regeln via Validator<T> zu verknüpfen,
- Am Ende eine saubere ValidationResult<T>-Antwort mit:
  - dem gebauten Objekt (T) oder
  - einer Liste von Fehlermeldungen.

Und das für jede Klasse wie z. B. Container<D, A> oder Person.

### 1. `ValidationResult<T>` (Hilfsklasse für das Ergebnis)

```java
public class ValidationResult<T> {
    private final T result;
    private final List<String> errors;

    public ValidationResult(T result, List<String> errors) {
        this.result = result;
        this.errors = errors;
    }

    public boolean isValid() {
        return errors == null || errors.isEmpty();
    }

    public T getResult() {
        return result;
    }

    public List<String> getErrors() {
        return errors;
    }
}
```

### 2. ValidatingBuilder<T> (generischer Builder mit Validierung)

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Supplier;

public class ValidatingBuilder<T> {
    protected final T instance;
    protected final List<Validator<T>> validators = new ArrayList<>();

    public ValidatingBuilder(Supplier<T> supplier) {
        this.instance = supplier.get();
    }

    public <U> ValidatingBuilder<T> with(BiConsumer<T, U> setter, U value) {
        setter.accept(instance, value);
        return this;
    }

    public ValidatingBuilder<T> withValidator(Validator<T> validator) {
        validators.add(validator);
        return this;
    }

    public ValidationResult<T> buildResult() {
        List<String> errors = new ArrayList<>();

        for (Validator<T> validator : validators) {
            Optional<String> result = validator.validate(instance);
            result.ifPresent(errors::add);
        }

        return new ValidationResult<>(instance, errors);
    }
}
```

### Beispielverwendung mit `Container<Document, DocumentAttribute>`

```java
Document doc = new Document();
DocumentAttribute attr = new DocumentAttribute();

ValidatingBuilder<Container<Document, DocumentAttribute>> builder =
    new ValidatingBuilder<>(Container::new)
        .with(Container::setDocument, doc)
        .with(Container::setAttributes, List.of(attr))
        .withValidator(Validator.of(c -> c.getDocument() != null, "Document darf nicht null sein"))
        .withValidator(Validator.of(c -> c.getAttributes() != null, "Attribute-Liste darf nicht null sein"))
        .withValidator(Validator.of(c -> !c.getAttributes().isEmpty(), "Es muss mindestens ein Attribut geben"));

ValidationResult<Container<Document, DocumentAttribute>> result = builder.buildResult();

if (result.isValid()) {
    Container<Document, DocumentAttribute> container = result.getResult();
    // Weiterverarbeiten...
} else {
    result.getErrors().forEach(System.out::println);
}
```

### Bonus: Kombinierte Regeln

Dein `Validator<T>`-Interface mit `and()/or()` erlaubt sehr schöne
Kombinationslogik:

```java
Validator<Container<Document, DocumentAttribute>> documentPresent =
    Validator.of(c -> c.getDocument() != null, "Dokument fehlt");

Validator<Container<Document, DocumentAttribute>> attributesValid =
    Validator.of(c -> c.getAttributes() != null && !c.getAttributes().isEmpty(), "Keine Attribute gesetzt");

builder.withValidator(documentPresent.and(attributesValid));
```

## Frage

Oder waere es besser dem ContainerBuilder eine Liste von Validatoren zu
uebergeben, die bei der der Methode build() auf dem Inhalt des Containers
ausgefuehrt werden?

## Antwort


Sehr gute und wichtige Frage! Beide Ansätze – der **generische**
`ValidatingBuilder<T>` und der **spezialisierte ContainerBuilder mit
integrierten Validatoren** – haben ihre Stärken. Welcher besser passt, hängt
davon ab, wie viel **Wiederverwendbarkeiti**, **Flexibilität** und
**Domänenspezifik** du brauchst.

### Kurzer Vergleich


| Kriterium                                  | `ValidatingBuilder<T>` (generisch)            | `ContainerBuilder` mit Validator-Liste      |
| ------------------------------------------ | --------------------------------------------- | ------------------------------------------- |
| ✅ **Wiederverwendbarkeit**                | Hoch – für beliebige Typen verwendbar         | Eher niedrig – nur für `Container<D,A>`     |
| ⚙️ **Flexibilität bei Regeln**             | Sehr flexibel (beliebige Validatoren)         | Mittel – Fokus auf Container-bezogene Logik |
| 🧠 **Lesbarkeit und Klarheit**             | Klar, wenn gut strukturiert                   | Klar, wenn nur Container validiert werden   |
| 🧱 **Domänenspezifische Kontrolle**        | Muss durch externe Validatoren ergänzt werden | Direkt eingebaut in ContainerBuilder        |
| 🔄 **Verhältnis von Bauen und Validieren** | Entkoppelt (sehr gut testbar)                 | Gekoppelt (einfacher in manchen Fällen)     |


### Variante 1: ContainerBuilder mit Validatoren


Vorteil:
- Du kapselst alles in einem spezialisierten Builder: Konstruktion + Validierung.
- Du kannst container-spezifische Regeln besser einschließen.
- Weniger generische "Plumbing" nötig, wenn du nur Container bauen willst.

Beispiel:

```java
public class ContainerBuilder<D, A> extends Builder<Container<D, A>, ContainerBuilder<D, A>> {

    private final List<Validator<Container<D, A>>> validators = new ArrayList<>();

    public ContainerBuilder() {
        super(Container::new);
    }

    public ContainerBuilder<D, A> withDocument(D document) {
        return with(Container::setDocument, document);
    }

    public ContainerBuilder<D, A> addAttribute(A attribute) {
        instance.addAttribute(attribute);
        return this;
    }

    public ContainerBuilder<D, A> withAttributes(List<A> attributes) {
        return with(Container::setAttributes, attributes);
    }

    public ContainerBuilder<D, A> withValidator(Validator<Container<D, A>> validator) {
        validators.add(validator);
        return this;
    }

    @Override
    protected ContainerBuilder<D, A> self() {
        return this;
    }

    public ValidationResult<Container<D, A>> buildResult() {
        List<String> errors = new ArrayList<>();
        for (Validator<Container<D, A>> validator : validators) {
            validator.validate(instance).ifPresent(errors::add);
        }
        return new ValidationResult<>(instance, errors);
    }

    @Override
    public Container<D, A> build() {
        ValidationResult<Container<D, A>> result = buildResult();
        if (!result.isValid()) {
            throw new IllegalStateException("Validation failed: " + String.join(", ", result.getErrors()));
        }
        return result.getResult();
    }
}
```

### Wann ist das besser?

- Wenn du nur `Container<D, A>` brauchst und nicht für jede Klasse einen neuen `ValidatingBuilder<T>` erzeugen willst.
- Wenn du **feste, domänenspezifische Regeln** innerhalb des Builders willst (z. B. Pflichtfelder).
- Wenn du **Builder + Validator zusammengehörig** betrachten möchtest (was in der Praxis oft sinnvoll ist).

### Empfehlung

Wenn du eine domänenspezifische Anwendung hast:
➤ Bevorzuge den spezialisierten `ContainerBuilder` mit Validatorliste.

Wenn du eine Library oder ein wiederverwendbares Tool bauen willst:
➤ Verwende den generischen `ValidatingBuilder<T>` und halte die Validatoren
  getrennt, eventuell sogar in wiederverwendbaren ValidatorSets.

### Hybrid: beides kombinieren


Du kannst auch folgendes machen:
- Nutze `ValidatingBuilder<T>` als Basis.
- Spezialisiere `ContainerBuilder` darauf:

```java
public class ContainerBuilder<D, A> extends ValidatingBuilder<Container<D, A>> {
    public ContainerBuilder() {
        super(Container::new);
    }

    public ContainerBuilder<D, A> withDocument(D document) {
        return (ContainerBuilder<D, A>) with(Container::setDocument, document);
    }

    public ContainerBuilder<D, A> addAttribute(A attribute) {
        instance.addAttribute(attribute);
        return this;
    }

    public ContainerBuilder<D, A> withAttributes(List<A> attributes) {
        return (ContainerBuilder<D, A>) with(Container::setAttributes, attributes);
    }
}
```

Dann hast du beides: **Generik + Spezialisierung**.

## Frage

Wie sehe ein Validator aus, der alle Attribute des Containers auf ein
Vorhandensein eines Attributs in der Klasse (z.B DocumentAttribute.pvaID mit
pvaID als Integer)?

## Antwort

Super Frage! Du möchtest einen Validator für `Container<D, A>`, der
sicherstellt, dass alle Attribute eine bestimmte Eigenschaft besitzen – z. B.
dass DocumentAttribute.pvaID != null ist.

### Ziel:

Ein Validator<Container<D, A>>, der prüft:

> Für **alle** `A` **in* `getAttributes()` gilt: `pvaID != null`

Das Ganze natürlich generisch, aber typensicher und wiederverwendbar.


### Voraussetzung: Zugriff auf pvaID

Wir müssen wissen, wie man bei einem `A`-Objekt (z. B. DocumentAttribute) den
Wert von `pvaID` bekommt. Das geht z. B. mit einem **Function<A, Integer>**,
also einem "Getter".

### Der Validator

```java
import java.util.function.Function;

public class AttributeFieldNotNullValidator<D, A> {

    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldNotNull(
            Function<A, U> fieldGetter,
            String fieldName
    ) {
        return container -> {
            if (container.getAttributes() == null) {
                return Optional.of("Attributliste ist null");
            }

            boolean allPresent = container.getAttributes().stream()
                    .allMatch(attr -> fieldGetter.apply(attr) != null);

            return allPresent
                    ? Optional.empty()
                    : Optional.of("Nicht alle Attribute haben ein gesetztes Feld: " + fieldName);
        };
    }
}
```

### Anwendung (Beispiel mit `DocumentAttribute`)


Angenommen:

```java
public class DocumentAttribute {
    private Integer pvaID;
    public Integer getPvaID() { return pvaID; }
    public void setPvaID(Integer pvaID) { this.pvaID = pvaID; }
}
```

Dann kannst du den Validator so verwenden:

```java
Validator<Container<Document, DocumentAttribute>> pvaIDValidator =
    AttributeFieldNotNullValidator
        .allAttributesFieldNotNull(DocumentAttribute::getPvaID, "pvaID");

builder.withValidator(pvaIDValidator);
```

### Optional: Mehrere Feld-Validatoren kombinieren


Wenn du willst, kannst du mehrere solcher Feldprüfungen kombinieren:

```java
builder
    .withValidator(pvaIDValidator)
    .withValidator(
        AttributeFieldNotNullValidator.allAttributesFieldNotNull(
            DocumentAttribute::getSomeOtherField, "someOtherField"
        )
    );
```

### Fazit

Mit der oben definierten Utility-Methode allAttributesFieldNotNull(...) kannst du:
- Typensicher definieren, welches Feld geprüft werden soll,
- Reusable Validatoren für jedes Attributfeld schreiben,
- Klar benennen, welches Feld fehlt, wenn die Validierung fehlschlägt.

Wenn du magst, kann ich dir noch eine Version zeigen, die auch z. B. prüft, ob
ein Feld innerhalb eines bestimmten Wertebereichs liegt. Sag einfach Bescheid!

## Frage

Dieser AttributeFieldNotNullValidator ist in deinem Beispiel keine Unterklasse
von Validator<T>. Warum?

## Antwort

Sehr guter Punkt – und du hast völlig recht, das verdient eine klare Erklärung.

### Warum ist AttributeFieldNotNullValidator keine Unterklasse von Validator<T>?

Weil:
Sie ist keine Implementierung, sondern nur ein Hilfs-Konstruktor für
`Validator<Container<D, A>>`.

### Was ist es dann?

Die Klasse (bzw. sie könnte auch einfach ein Utility-Class sein) liefert eine
Instanz von `Validator<Container<D, A>>`, aber sie selbst implementiert nicht das
Interface `Validator<T>`.

```java
public class AttributeFieldNotNullValidator<D, A> {

    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldNotNull(
            Function<A, U> fieldGetter,
            String fieldName
    ) {
        return container -> {
            // Validation logic ...
        };
    }
}
```

### Alternativen – was wäre möglich?

1. Utility-Klasse (empfohlen)
So wie oben – AttributeFieldNotNullValidator ist einfach nur ein Helper mit statischen Methoden.

👉 Vorteil: Kein Overhead, keine unnötige Vererbung, sehr lesbar.

2. Eigene Validator-Klasse (falls du Instanzvariablen brauchst)
Wenn du z. B. den fieldGetter und fieldName als Felder halten willst:

```java
public class AttributeFieldNotNullValidator<D, A, U> implements Validator<Container<D, A>> {
    private final Function<A, U> getter;
    private final String fieldName;

    public AttributeFieldNotNullValidator(Function<A, U> getter, String fieldName) {
        this.getter = getter;
        this.fieldName = fieldName;
    }

    @Override
    public Optional<String> validate(Container<D, A> container) {
        if (container.getAttributes() == null) {
            return Optional.of("Attributliste ist null");
        }

        boolean allPresent = container.getAttributes().stream()
                .allMatch(attr -> getter.apply(attr) != null);

        return allPresent
                ? Optional.empty()
                : Optional.of("Nicht alle Attribute haben ein gesetztes Feld: " + fieldName);
    }
}
```

Dann kannst du ihn auch so verwenden:

```java
builder.withValidator(
    new AttributeFieldNotNullValidator<>(DocumentAttribute::getPvaID, "pvaID")
);
```

### Empfehlung

| Situation                                   | Lösung                                                 |
| ------------------------------------------- | ------------------------------------------------------ |
| 🔁 Einmalige oder einfache Verwendung       | Nutze eine `static`-Factory-Methode (wie oben gezeigt) |
| 🔧 Komplexe Logik, erweiterbare Validatoren | Nutze eine eigene `Validator`-Implementierungsklasse   |

## Frage

Kann man die letzte Loesung auch in einen `Validator.of()` Aufruf verwandeln? 

## Antwort

Ja, absolut! Du kannst die letzte Lösung – also die Prüfung, ob bei allen
Attributen eines Containers ein bestimmtes Feld gesetzt ist – auch vollständig
in einen Aufruf von Validator.of(...) packen, wenn du lieber inline arbeitest
oder auf eine Utility-Klasse verzichten möchtest.

### Beispiel: `Validator.of(...)` für `DocumentAttribute.pvaID != null`

Angenommen:

```java
public class DocumentAttribute {
    private Integer pvaID;

    public Integer getPvaID() {
        return pvaID;
    }

    public void setPvaID(Integer pvaID) {
        this.pvaID = pvaID;
    }
}
```

Dann kannst du den `Validator<Container<D, A>>` direkt so bauen:

```java
Validator<Container<Document, DocumentAttribute>> pvaIDValidator =
    Validator.of(
        container -> container.getAttributes() != null &&
                     container.getAttributes().stream().allMatch(attr -> attr.getPvaID() != null),
        "Nicht alle Attribute haben ein gesetztes Feld: pvaID"
    );
```
### Fazit

Ja, du kannst und solltest solche einfachen Validierungen direkt mit Validator.of(...) definieren, wenn:
- sie kurz und verständlich sind,
- du keine zustandsbehaftete Klasse brauchst.
Für komplexere oder wiederholte Validierungen lohnt sich ein Utility oder eine eigene Validator-Klasse.

Wenn du magst, kann ich dir ein kleines ValidatorUtils-Toolkit mit solchen Methoden zusammenstellen.

## Frage

na dann Zeige mit dieses ValidatorUtils. Danke dir. :) Ist eine tolle Idee!

## Antwort

Sehr gerne – freut mich, dass dir die Idee gefällt! 🎉

Hier ist ein **generisches** `ValidatorUtils` **Toolkit**, das dir hilft,
typische Validierungen für Container-Objekte und deren Attribute zu kapseln und
wiederzuverwenden. Es ist **typsicher**, flexibel und Java-idiomatisch gehalten.

### ValidatorUtils – die Klasse

```java
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public final class ValidatorUtils {

    private ValidatorUtils() {
        // Utility class – no instantiation
    }

    /**
     * Prüft, ob ein Feld in allen Attributen vorhanden ist (nicht null).
     */
    public static <D, A, U> Validator<Container<D, A>> allAttributesHaveField(
            Function<A, U> fieldGetter,
            String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream().allMatch(attr -> fieldGetter.apply(attr) != null),
            "Nicht alle Attribute haben ein gesetztes Feld: " + fieldName
        );
    }

    /**
     * Prüft, ob mindestens ein Attribut das Feld erfüllt.
     */
    public static <D, A, U> Validator<Container<D, A>> anyAttributeHasFieldMatching(
            Function<A, U> fieldGetter,
            Predicate<U> predicate,
            String errorMessage
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .anyMatch(value -> value != null && predicate.test(value)),
            errorMessage
        );
    }

    /**
     * Prüft, ob alle Attribute ein Feld innerhalb eines Wertebereichs haben.
     */
    public static <D, A, U extends Comparable<U>> Validator<Container<D, A>> allAttributesFieldInRange(
            Function<A, U> fieldGetter,
            U min,
            U max,
            String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(value -> value != null && value.compareTo(min) >= 0 && value.compareTo(max) <= 0),
            String.format("Feld '%s' muss zwischen %s und %s liegen", fieldName, min, max)
        );
    }

    /**
     * Prüft, ob alle Attribute eine Liste von erlaubten Werten enthalten.
     */
    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldInAllowedValues(
            Function<A, U> fieldGetter,
            List<U> allowedValues,
            String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(allowedValues::contains),
            String.format("Feld '%s' enthält ungültige Werte. Erlaubt sind: %s", fieldName, allowedValues)
        );
    }

    /**
     * Prüft, ob die Attributliste leer ist.
     */
    public static <D, A> Validator<Container<D, A>> attributesNotEmpty(String errorMessage) {
        return Validator.of(
            container -> container.getAttributes() != null && !container.getAttributes().isEmpty(),
            errorMessage
        );
    }

    /**
     * Kombiniert mehrere Validatoren in einen einzigen.
     */
    @SafeVarargs
    public static <T> Validator<T> combineAll(Validator<T>... validators) {
        return t -> {
            for (Validator<T> validator : validators) {
                Optional<String> result = validator.validate(t);
                if (result.isPresent()) return result;
            }
            return Optional.empty();
        };
    }

    /**
     * Führt alle Validatoren aus und sammelt alle Fehler (nicht nur den ersten).
     */
    @SafeVarargs
    public static <T> Validator<T> collectAllErrors(Validator<T>... validators) {
        return t -> {
            List<String> errors = 
                List.of(validators).stream()
                    .map(v -> v.validate(t))
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .collect(Collectors.toList());

            return errors.isEmpty()
                ? Optional.empty()
                : Optional.of(String.join("; ", errors));
        };
    }
}
```

### Beispielnutzung

```java
Validator<Container<Document, DocumentAttribute>> validator = ValidatorUtils.combineAll(
    ValidatorUtils.attributesNotEmpty("Die Attributliste darf nicht leer sein"),
    ValidatorUtils.allAttributesHaveField(DocumentAttribute::getPvaID, "pvaID"),
    ValidatorUtils.allAttributesFieldInRange(DocumentAttribute::getPvaID, 1000, 9999, "pvaID")
);
```

Oder mit deinem `ContainerBuilder`:

```java
ContainerBuilder<Document, DocumentAttribute> builder = new ContainerBuilder<>();

builder
    .withDocument(new Document())
    .addAttribute(new DocumentAttribute(1234)) // z. B. mit gesetztem pvaID
    .withValidator(validator);
```

### Erweiterungsideen

Du kannst ValidatorUtils ganz einfach erweitern um:
- Pflichtfelder auf dem Container selbst (nicht nur Attributebene)
- Einzigartigkeit (z. B. kein Attribut hat denselben Schlüssel)
- Kombinationsregeln (z. B. „wenn A gesetzt ist, muss B gesetzt sein“)

## Frage

Wie sehe das aus: Kombinationsregeln (z. B. „wenn A gesetzt ist, muss B gesetzt sein“)?

## Antwort


Sehr gute Frage – **Kombinationsregel**n („Wenn A, dann B“) sind in der
Validierung von Objekten extrem wichtig, und elegant lösbar, wenn man mit dem
`Validator<T>`-Prinzip arbeitet.

### Ziel:

Wenn Feld A **gesetzt** ist, dann **muss auch Feld B gesetzt** sein (z. B. nicht null).

Oder umgekehrt:

Wenn A **nicht gesetzt** ist, darf B **auch nicht gesetzt sein**. (Optional: symmetrisch oder einseitig prüfen.)

### Beispiel (konkret mit DocumentAttribute):

```java
public class DocumentAttribute {
    private String key;
    private String value;

    // z. B.
    // if key != null => value != null
}
```

### Kombinationsregel-Validator (typsicher und wiederverwendbar)

```java
public class ValidatorUtils {

    // ...

    /**
     * Wenn Feld A gesetzt ist, muss Feld B auch gesetzt sein.
     */
    public static <T, U, V> Validator<T> ifFieldSetThenOtherFieldMustBeSet(
            Function<T, U> fieldAGetter,
            Function<T, V> fieldBGetter,
            String fieldAName,
            String fieldBName
    ) {
        return Validator.of(
            t -> {
                U fieldA = fieldAGetter.apply(t);
                V fieldB = fieldBGetter.apply(t);

                // Wenn A gesetzt ist, muss B auch gesetzt sein
                return fieldA == null || fieldB != null;
            },
            String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein", fieldAName, fieldBName)
        );
    }

}
```

### Beispielnutzung mit einem einzelnen DocumentAttribute:

```java

    ValidatorUtils.ifFieldSetThenOtherFieldMustBeSet(
        DocumentAttribute::getKey,
        DocumentAttribute::getValue,
        "key",
        "value"
    );
```

### Erweiterung für eine `Container<D, A>`-Struktur:

```java
public static <D, A, U, V> Validator<Container<D, A>> attributeFieldDependency(
        Function<A, U> fieldAGetter,
        Function<A, V> fieldBGetter,
        String fieldAName,
        String fieldBName
) {
    return Validator.of(
        container -> container.getAttributes() != null &&
                     container.getAttributes().stream()
                             .allMatch(attr -> {
                                 U fieldA = fieldAGetter.apply(attr);
                                 V fieldB = fieldBGetter.apply(attr);
                                 return fieldA == null || fieldB != null;
                             }),
        String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein (bei mindestens einem Attribut verletzt)", fieldAName, fieldBName)
    );
}
```

Dann so verwenden:

```java
Validator<Container<Document, DocumentAttribute>> validator =
    ValidatorUtils.attributeFieldDependency(
        DocumentAttribute::getKey,
        DocumentAttribute::getValue,
        "key",
        "value"
    );
```

### Weitere Varianten möglich:

| Regeltyp                                                       | Beispiel                           |
| -------------------------------------------------------------- | ---------------------------------- |
| Wenn A gesetzt ist, darf B **nicht** gesetzt sein              | Konfliktprüfung                    |
| Wenn A einen bestimmten **Wert** hat, dann muss B gesetzt sein | Konfiguration abhängig von Auswahl |
| Wenn A == X, dann B == Y                                       | Kopplung von Feldern               |

## Frage

Wenn du magst, kann ich dir aus diesen Methoden direkt eine kompakte
ValidatorUtils.java Datei zum Copy-Paste liefern – einfach Bescheid sagen.

## Antwort

Ja pack mir diese Methoden in eine ValidatorUtils Klasse.

Sehr gerne! Hier ist die vollständige und saubere ValidatorUtils-Klasse mit
allen besprochenen Methoden für kombinatorische Validierungen und
Standardprüfungen von Feldern in Containern und Objekten.

### ValidatorUtils.java

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

public final class ValidatorUtils {

    private ValidatorUtils() {
        // Utility class — no instantiation
    }

    // === Standard Container-Validatoren ===

    public static <D, A> Validator<Container<D, A>> attributesNotEmpty(String errorMessage) {
        return Validator.of(
            container -> container.getAttributes() != null && !container.getAttributes().isEmpty(),
            errorMessage
        );
    }

    public static <D, A, U> Validator<Container<D, A>> allAttributesHaveField(
        Function<A, U> fieldGetter,
        String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream().allMatch(attr -> fieldGetter.apply(attr) != null),
            "Nicht alle Attribute haben ein gesetztes Feld: " + fieldName
        );
    }

    public static <D, A, U, V> Validator<Container<D, A>> attributeFieldDependency(
        Function<A, U> fieldAGetter,
        Function<A, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .allMatch(attr -> {
                                 U a = fieldAGetter.apply(attr);
                                 V b = fieldBGetter.apply(attr);
                                 return a == null || b != null;
                             }),
            String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein (in einem Attribut verletzt)", fieldAName, fieldBName)
        );
    }

    public static <D, A, U extends Comparable<U>> Validator<Container<D, A>> allAttributesFieldInRange(
        Function<A, U> fieldGetter,
        U min,
        U max,
        String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(value -> value != null && value.compareTo(min) >= 0 && value.compareTo(max) <= 0),
            String.format("Feld '%s' muss zwischen %s und %s liegen", fieldName, min, max)
        );
    }

    public static <D, A, U> Validator<Container<D, A>> allAttributesFieldInAllowedValues(
        Function<A, U> fieldGetter,
        List<U> allowedValues,
        String fieldName
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream()
                             .map(fieldGetter)
                             .allMatch(allowedValues::contains),
            String.format("Feld '%s' enthält ungültige Werte. Erlaubt sind: %s", fieldName, allowedValues)
        );
    }

    public static <D, A> Validator<Container<D, A>> attributesMustSatisfy(
        Predicate<A> attributePredicate,
        String errorMessage
    ) {
        return Validator.of(
            container -> container.getAttributes() != null &&
                         container.getAttributes().stream().allMatch(attributePredicate),
            errorMessage
        );
    }

    // === Kombinationsregeln (Feldabhängigkeiten) ===

    public static <T, U, V> Validator<T> ifFieldSetThenOtherFieldMustBeSet(
        Function<T, U> fieldAGetter,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return a == null || b != null;
            },
            String.format("Wenn '%s' gesetzt ist, muss auch '%s' gesetzt sein", fieldAName, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldSetThenOtherFieldMustBeNull(
        Function<T, U> fieldAGetter,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return a == null || b == null;
            },
            String.format("Wenn '%s' gesetzt ist, darf '%s' nicht gesetzt sein", fieldAName, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldUnsetThenOtherFieldMustAlsoBeUnset(
        Function<T, U> fieldAGetter,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return a != null || b == null;
            },
            String.format("Wenn '%s' nicht gesetzt ist, darf '%s' auch nicht gesetzt sein", fieldAName, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldEqualsThenOtherFieldRequired(
        Function<T, U> fieldAGetter,
        U expectedValue,
        Function<T, V> fieldBGetter,
        String fieldAName,
        String expectedValueLabel,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return !Objects.equals(a, expectedValue) || b != null;
            },
            String.format("Wenn '%s' == %s, muss '%s' gesetzt sein", fieldAName, expectedValueLabel, fieldBName)
        );
    }

    public static <T, U, V> Validator<T> ifFieldEqualsThenOtherMustEqual(
        Function<T, U> fieldAGetter,
        U expectedA,
        Function<T, V> fieldBGetter,
        V expectedB,
        String fieldAName,
        String fieldBName
    ) {
        return Validator.of(
            t -> {
                U a = fieldAGetter.apply(t);
                V b = fieldBGetter.apply(t);
                return !Objects.equals(a, expectedA) || Objects.equals(b, expectedB);
            },
            String.format("Wenn '%s' == %s, muss '%s' == %s sein", fieldAName, expectedA, fieldBName, expectedB)
        );
    }

    // === Zusammensetzung ===

    @SafeVarargs
    public static <T> Validator<T> combineAll(Validator<T>... validators) {
        return t -> {
            for (Validator<T> v : validators) {
                Optional<String> error = v.validate(t);
                if (error.isPresent()) return error;
            }
            return Optional.empty();
        };
    }

    @SafeVarargs
    public static <T> Validator<T> collectAllErrors(Validator<T>... validators) {
        return t -> {
            List<String> errors = Arrays.stream(validators)
                .map(v -> v.validate(t))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());

            return errors.isEmpty()
                ? Optional.empty()
                : Optional.of(String.join("; ", errors));
        };
    }
}
```

### Jetzt kannst du z. B. schreiben:

```java
Validator<Container<Document, DocumentAttribute>> validator = ValidatorUtils.combineAll(
    ValidatorUtils.attributesNotEmpty("Mindestens ein Attribut muss vorhanden sein"),
    ValidatorUtils.allAttributesHaveField(DocumentAttribute::getPvaID, "pvaID"),
    ValidatorUtils.attributeFieldDependency(DocumentAttribute::getKey, DocumentAttribute::getValue, "key", "value"),
    ValidatorUtils.ifFieldEqualsThenOtherMustEqual(
        DocumentAttribute::getKey, "status",
        DocumentAttribute::getValue, "ACTIVE",
        "key", "value"
    )
);
```
