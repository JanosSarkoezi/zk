# Funktionales Factory Pattern

## Frage

Wie sehe das FactoryDesignpattern in Java aus, wenn man funktional
programmieren moechte?

## Antwort

Wenn du das **Factory Design Pattern** in Java funktional umsetzen möchtest,
kannst du anstatt klassischer abstrakter Fabrikklassen und Unterklassen einfach
**Funktionen, Lambdas und Functional Interfaces** verwenden.

Die Idee:

* Eine Factory ist nichts anderes als eine **Funktion**, die Eingaben
  entgegennimmt und ein Objekt erzeugt.
* Statt `new` direkt zu verwenden, speicherst du **Konstruktor-Referenzen oder
  Lambdas** in einer Map oder Variablen.

## Beispiel: Funktionale Factory in Java

Angenommen, wir wollen verschiedene `Shape`-Objekte erzeugen:

```java
@FunctionalInterface
interface ShapeFactory {
    Shape create();
}

interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { System.out.println("Circle"); }
}

class Square implements Shape {
    public void draw() { System.out.println("Square"); }
}
```

---

### Funktionale Factory mit `Map` und Lambdas

```java
import java.util.Map;
import java.util.function.Supplier;

public class FunctionalFactoryExample {
    public static void main(String[] args) {
        // Map von "Typname" → Konstruktor
        Map<String, Supplier<Shape>> factory = Map.of(
                "circle", Circle::new,
                "square", Square::new
        );

        // Nutzung
        Shape shape1 = factory.get("circle").get();
        Shape shape2 = factory.get("square").get();

        shape1.draw(); // Circle
        shape2.draw(); // Square
    }
}
```

**Vorteile:**

* Keine langen `if`- oder `switch`-Ketten.
* Konstruktor-Referenzen (`ClassName::new`) sind klar und kurz.
* Erweiterbar: Neue Typen einfach per `.put()` hinzufügen.

---

### Erweiterte Variante: Parameterisierte Factory

Falls Konstruktoren Parameter brauchen, kann man statt `Supplier` ein eigenes funktionales Interface oder z. B. `Function` verwenden:

```java
import java.util.Map;
import java.util.function.Function;

class Rectangle implements Shape {
    private final int width;
    public Rectangle(int width) { this.width = width; }
    public void draw() { System.out.println("Rectangle width=" + width); }
}

public class ParamFactoryExample {
    public static void main(String[] args) {
        Map<String, Function<Integer, Shape>> factory = Map.of(
                "rectangle", Rectangle::new
        );

        Shape rect = factory.get("rectangle").apply(42);
        rect.draw(); // Rectangle width=42
    }
}
```

---

### Kernidee der funktionalen Variante

* **Factory = Funktion** (z. B. `Supplier`, `Function`, `BiFunction` oder eigenes Interface)
* **Mapping von Keys zu Konstruktor-Referenzen**
